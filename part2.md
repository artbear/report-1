# Разработка синтаксического анализатора языка запросов на языке 1С

Бомбин Валентин <[wwall@yandex.ru](mailto:wwall@yandex.ru)>

## 1. О чем будем говорить?

Сегодня мы поговорим о том как имя примитивные парсеры описанные в
предыдущей статье собрать простой генератор синтаксических анализаторов,
построим парсеры для пары простых грамматик и сделаем парсер для языка
запросов. Тема кеширования и получения позиции откладывается до
следующей статьи. Из инструментов чуть позже потребуется утилита
v8Unpack

## 2. Разбор арифметического выражения

Начнем мы с простого - напишем парсер для грамматики разбора
арифметических выражений. Сама грамматика представлена ниже

 >_digits_<   ` ::= `>_[`0-9`]_<+                       
 >_number_<   ` ::= `>_digits_< [{`.` >_digits_<}]      
 >_operation_<` ::= ``+  |  -`                          
 >_exp_<      ` ::= `>_number_< >_operation_< >_number_<

Конечно же бросается в глаза ущербность грамматики, но поводов перживать
нет - по ходу статьи будут добавлены недостающие операции и скобки.
Сейчас для вас главное понять как формальное определение преобразуется в
код, разбирающий строку.

### 2.1. Некрасивая, но нужная реализация

Перевод в код осуществляется буквально - как написано в грамматике - так
и определяем парсеры. Опеределение для

 >_digits_<` ::= `>_[`0-9`]_<+

легко разбивается на 2 парсера - первый разбирает интервал, второй -
одно или более вхождений первого парсера. В коде это выглядит так

digits = ПостроитьПарсер("+",ПостроитьПарсер("range",Новый Структура("Минимум,Максимум","0","9"))); 

На примере теста видно как строить и вызывать парсер :

Функция Парсер\_РазобратьЧисло()
        digits = ПостроитьПарсер("+",ПостроитьПарсер("range",Новый Структура("Минимум,Максимум","0","9")));
        number = ПостроитьПарсер("seq",ВМассив(digits,ПостроитьПарсер("?",ПостроитьПарсер("seq",ВМассив(ПостроитьПарсер("match","."),digits)))));
        Возврат number; Конецфункции
Процедура ТестОпределениеЦелогоЧисла() Экспорт
    результат = ПрименитьПарсер(Парсер\_РазобратьЧисло(),"1234");
        юТест.ПроверитьРавенствоРекурсивно(Значение(результат)[0],ВМассив("1","2","3","4"));
Конецпроцедуры  Процедура ТестОпределениеДробногоЧисла() Экспорт
    результат = ПрименитьПарсер(Парсер\_РазобратьЧисло(),"1234.4321");
        юТест.ПроверитьРавенствоРекурсивно(Значение(результат),ВМассив(ВМассив("1","2","3","4"),ВМассив(".",ВМассив("4","3","2","1"))));
Конецпроцедуры   

Здесь вы видите вызов ПроверитьРавенствоРекурсивно() , в стандартной
поставке xUnitFor1C такого метода нет, пришлось дописать, что бы вы
смотрели на тест, и не отвлекались на операцию сравнения. В дальнейшем
во всей статье будет имельзоваться именно это расширение, скачать его
можно   [здесь](https://github.com/wwall/xUnitFor1C.git)

Оставшиеся нетерминалы - exp,operaiton, number определяются аналогично.
Экономя ваше время, не буду произносить тысячи слов оъяснений, просто
покажу тест

Процедура ТестАрифметика1() Экспорт
        number = Парсер\_РазобратьЧисло();
        operation = ПостроитьПарсер("/",ВМассив(ПостроитьПарсер("match","+"),ПостроитьПарсер("match","-")));
        exp = ПостроитьПарсер("seq",ВМассив(number,operation,number));
        результат = ПрименитьПарсер(exp,"12.34+43.21");
        юТест.ПроверитьРавенствоРекурсивно(Значение(результат),
                ВМассив(                         ВМассив(
                                ВМассив("1","2"),
                                ВМассив(".",ВМассив("3","4"))),
                        "+",                         ВМассив(
                                ВМассив("4","3"),
                                ВМассив(".",ВМассив("2","1")))));
Конецпроцедуры  

Как видим  - строка вполне корректно разбирвается на символы и
группируется по нетерминалам. Осталось простая вещь - преобразовать
результат в число и вернуть его. Определим функцию преобразования
результата в число и напишем тест для проверки.

Функция РезультатВЧисло(значение)
        ЦелаяЧасть = МассивВСтроку(значение(значение)[0]);
        ДробнаяЧасть = "";
        Если Не значение(значение)[1] = Неопределено Тогда
                ДробнаяЧасть = МассивВСтроку(значение(значение)[1][1]);
        Конецесли;         Возврат Число(ЦелаяЧасть+"."+ДробнаяЧасть);
Конецфункции  Функция Парсер\_РазобратьЧисло()
        digits = ПостроитьПарсер("+",ПостроитьПарсер("range",Новый Структура("Минимум,Максимум","0","9")));
        number = ПостроитьПарсер("seq",ВМассив(digits,ПостроитьПарсер("?",ПостроитьПарсер("seq",ВМассив(ПостроитьПарсер("match","."),digits)))));
        Возврат ПостроитьПарсер("fn",Новый Структура("Функция,Парсер","РезультатВЧисло",number));
Конецфункции  

Функция МассивВстроку()  простая и написать ее можете сами, или
посмотреть в файле ariph-2.epf.         А тест заставим сразу проверить
разбор и дробного и целого числа

Процедура ТестПреобразованиеЧисла() Экспорт
        number = Парсер\_РазобратьЧисло();
        результатДробь = ПрименитьПарсер(number,"1234.4321");
        РезультатЦелое = ПрименитьПарсер(number,"1234");
        юТест.ПроверитьРавенство(Значение(результатДробь)+Значение(РезультатЦелое),1234+1234.4321);
Конецпроцедуры 

Теперь когда у нас есть парсер числа и функция преобразования массива в
число, мы можем написать тест для проверки работоспособности парсера
выражения в целом. Выглядеть он будет, например, так :

Процедура ТестРазбор() Экспорт
        number = Парсер\_РазобратьЧисло();
        operation = ПостроитьПарсер("/",ВМассив(ПостроитьПарсер("match","+"),ПостроитьПарсер("match","-")));
        exp = ПостроитьПарсер("fn",Новый Структура("Функция,Парсер","ПрименитьОперацию",ПостроитьПарсер("seq",ВМассив(number,operation,number))));
        результат = ПрименитьПарсер(exp,"12.34+43.21");
        юТест.ПроверитьРавенство(Значение(результат),12.34+43.21);
Конецпроцедуры 

Если что вам в этом коде не понятно - пройдитесь с отладчком по коду в
файле  ariph-2.epf.

На самом деле мы можем на этом остановиться - код реализует заявленный
функционал, но мы его все же препишем. Сделаем код просто посимпотичней
и обоснуем преход который будет выполнен в п. 2.3.

### 2.2. Сделаем симпатично

Первое, о чем возникает мысль (если вы ранее не писали на лиспе), когда
видишь код Парсер\_РазобратьЧисло()  - сократить количество вызовов
функци и скобок. Даже в отсутствие макросов, эта задача не является
сложной, необходимо просто определиться - как будет выгядеть код. Вот
один из вариантов -

Функция Парсер\_РазобратьЧисло()
        digits = \_plus(\_range("0","9"));  _// digits = +[0-9]_
        number = \_seq(digits,\_quest(\_seq(\_match("."),digits))); _//
number = digits ?("." digits)_
        Возврат \_fn("РезультатВЧисло",number); Конецфункции 

Определения для функции \_seq, \_match и т.д. вы можете цвидеть в файле
arith-3.epf. Эта правка - не более чем редактурское упрощение текста,
поэтому тесты из предыдущещего файла вполне подойдут. Приводить их здесь
не буду, но в файле они есть и работают без ошибок

### 2.3. Попытаемся расширить граматику

В начале статьи я обещал вам что наша кастированная грамматика будет
улучшена и позволит разбирать самые сложные выражения. Пришло время это
обещание выполнять. Начнем с грамматики -

 >_digits_<` ::= `>_[`0-9`]_<+                     
 >_X_<     ` ::= `>_digits_< [{`.` >_digits_<}]    
 >_F_<     ` ::= ``(` >_S_< `)  |  `>_X_<          
 >_T_<     ` ::= `>_F_< `*  |  /` >_T_<`  |  `>_F_<
 >_S_<     ` ::= `>_T_< `+  |  -` >_S_<`  |  `>_T_<

Учитывая что все необходимые для работы функции у нас есть, перевод
грамматики не должен составить проблемы. И в первом приближении код
может выглядить так -

Функция Парсер\_РазобратьЧисло()
        digits = \_plus(\_range("0","9")); _ // digits = +[0-9]_
        X = \_seq(digits,\_quest(\_seq(\_match("."),digits))); _//
number = digits ?("." digits)_
        F = \_choose(\_seq(\_match("("),S,\_match(")")),X); 
        T = \_choose(\_seq(F,\_choose(\_match("\*"),\_match("/")),T),F); 
        S = \_choose(\_seq(T,\_choose(\_match("+"),\_match("-")),S),T); 
        Возврат S; Конецфункции 

Работать это код не будет, так как для определения переменной F
требуется переменная S. Конечно, трудолюбивый читатель сможет написать
еще 12 строк кода что бы в текущей модели представления парсера и это
определение работало, но мне почему то кажется что все перейдут к чтению
следующего пункта, и не будут тратить свое время на изобретение
трехколесного велосипеда.

### 2.4. Включим наконец мозг

В принятой ранее модели парсера есть одна, но принципиальная, ошибка. В
ней объявление терминала/нетерминала не отделимо от его описания. В этой
части статьи мы с формулируем требования к новому парсеру.

Очевидно что нам потребуется -

* Иметь возможность много хранить правил

* Иметь возможность объявлять имя правила

* Иметь возможность обращаться к телу правила по имени

* Внести изменения (желательно минимальные) в ранее разработанный код

Исходя из этих требований становится понятно, что нам требуется
коллекция, позволяющая обращаться по ключу. В 1С таких коллекций 2 -
Соответствие и Структура (по большомук счету, вы можете использовать
любую коллекцию, но вот доступ по ключу придется изобретать самому).

Для упрощения работы далее в качестве коллекции будет использована
Структура, но вам ничего не мешает переписать в случае необходимости
свой код под любую другую коллекцию

Напишем ожидаемый код функции и подумаем как бы его обеспечить

Функция ДобавитьОпеределениеВПарсер(Парсер,Имя,ОписаниеПарсера)
        Если Парсер.Свойство(Имя) Тогда
                Вызватьисключение "Уже определено правило:"+Имя;
        Конецесли;         Парсер.Вставить(Имя,ОписаниеПарсера);
Конецфункции  Функция Парсер\_РазобратьЧисло()
        Парсер = Новый Структура;
        ДобавитьОпеределениеВПарсер(Парсер,"digits",\_plus(\_range("0","9")));
        ДобавитьОпеределениеВПарсер(Парсер,"X",\_seq("digits",\_quest(\_seq(\_match("."),"digits"))));
        ДобавитьОпеределениеВПарсер(Парсер,"F",\_choose(\_seq(\_match("("),"S",\_match(")")),"X"));
        ДобавитьОпеределениеВПарсер(Парсер,"T",\_choose(\_seq("F",\_choose(\_match("\*"),\_match("/")),"T"),"F"));
        ДобавитьОпеределениеВПарсер(Парсер,"S",\_choose(\_seq("T",\_choose(\_match("+"),\_match("-")),"F"),"T"));
        Возврат Парсер; Конецфункции 

Так как теперь весь наш парсер собран в одной структуре, то надо
переписать функцию ПрименитьПарсер()  и все функции отвечающие за разбор
примтивов, что бы они умели работать с новым представлением парсера

Ниже приведены 2 функции - ПрименитьПарсер() , и, для понимания работы c
новым представлением парсера, функция ПоследовательностьПарсеров() 

Функция ПоследовательностьПарсеров(ОписаниеПарсера,ПоследовательностьПарсеров,СтрокаАнализа)
        МассивВозврата = Новый Массив;
        СтрокаРаботы = СтрокаАнализа;
        Для Каждого Парсер Из ПоследовательностьПарсеров.Парсер Цикл
                РезультатРаботы = ПрименитьПарсер(ОписаниеПарсера,Парсер,СтрокаРаботы);
                Если Неудача(РезультатРаботы) Тогда
                        Возврат РазобраноНеудачно(СтрокаАнализа);
                Конецесли;
                МассивВозврата.Добавить(ВСтруктуру(Парсер,Значение(РезультатРаботы)));
                СтрокаРаботы = Остаток(РезультатРаботы);
        Конеццикла;
        Возврат РазобраноУспешно(МассивВозврата,СтрокаРаботы,ПоследовательностьПарсеров.Имя);
Конецфункции
Функция ПрименитьПарсер(ОписаниеПарсера,Имя, СтрокаАнализа)
        Парсер = Неопределено;
        Если ТипЗнч(Имя) = Тип("Строка") Тогда
                Если Не ОписаниеПарсера.Свойство(Имя,Парсер) Тогда
                        Вызватьисключение "Не найдено правило "+Имя;
                Конецесли;
                Если ТипЗнч(Парсер) = Тип("Строка") Тогда
                        Возврат ПрименитьПарсер(ОписаниеПарсера,Парсер, СтрокаАнализа);
                Конецесли;         Иначе                 Парсер = Имя;
        Конецесли;         \_Функция = СписокФункций [Парсер.Тип];
        Если \_Функция = Неопределено Тогда
                Вызватьисключение "Неизвестный тип парсера "+Парсер.Тип;
        Конецесли;
        Возврат Вычислить(\_Функция + "(ОписаниеПарсера,Парсер,СтрокаАнализа)");
Конецфункции   

Если что вам в этом коде не понятно - пройдитесь с отладчком по коду в
файле  ariph-4.epf.

<ЛирическоеОтступление>

Как вы видите - увиличилось количество параметров, усложнилась немного
логика выбора парсера и после взгляда на функцию ПрименитьОперацию1() 
возникает  дежавю - уж не франчайзи ли этот код пишут.Дабы развеять
опасения - нет, не франчайзи. Сертификтов не получал, писать так же
красиво, как некоторые франчази "Входящие в TOP-5" не умею, но иногда,
как вы видите - получается.

</ЛирическоеОтступление>

#### 2.4.1. Для чего эти муки?

Лирическое отсупление предыдущего абзаца навевает фантазии, и из их
глубины появляется желание не писать ничего кроме грамматики. Вот
конкретно мне хочется написать просто так -

Функция Парсер\_РазобратьЧисло()         Парсер = СоздатьПарсер("
|digits = +[0-9]                 |X = digits ?(""."" disgits)
|F = ""("" S "")"" | X                 |T = F (""\*"" | ""/"") T | F
|S = T (""+"" | ""-"") S | T"; _О том что не выставляет переносы строк
знаю, в финальной версии будет исправлено. Самые нетерпеливые - смотрите
функцию Парсер\_РазобратьЧисло() в файле arith5.epf_
        Возврат Парсер; Конецфункции 

и не думать - как, что, где и в каком порядке объявиться. Раз желание -
мое, то и выполнять мне. Это значит, мой верный читатель, что следующая
часть статьи объяснит тебе ради чего, так долго и муторно ты продирался
через дебри чужого кода.

## 3. Не пишите код

### 3.1. Почему код не надо писать?

В замечательной книге [Эндрю Ханта
"Программист-прагматик"](http://yandex.ru/yandsearch?text=%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%20%D0%BF%D1%80%D0%B0%D0%B3%D0%BC%D0%B0%D1%82%D0%B8%D0%BA)
есть глава посвященная генерации текстов программ. Конкретно сейчас нам
интересны "активные генераторы", то есть такие которые на основании
модели кода генерируют текст.

Самые продвинутые читатели конечно же вспомнили сейчас о таких
программах как yacc, bison, ANTLR. О плюсах которые они дают, ну и
конечно же о минусах. И конечно же жогадались что мы сейчас будем
делать. Что бы не обманывать их ожиданий скажу - да, мы сейчас напишем
генератор лексических анализаторов. Только вот похож он будет больше на
[waxeye](http://waxeye.org/) либо
[PEG.js](https://github.com/pegjs/pegjs)

### 3.2. Из чего состоит генератор?

Генератор текста программы состоит из описания модели, парсера языка
модели и блока формирования/вывода кода.

Таким образом в ближайшее время нам предстоит разработать либо взять
готовый язык описания грамматики, структуру внутреннего представления
прочитаной и разобранной грамматики и сделать процедуру генерации текста
программы по внутреннему представлению.

### 3.3. Что бы понять рекурсию - надо понять рекурсию

Итак, мы начнем с разработки грамматики определяющей грамматику которую
будет уметь обрабатывать генератор парсеров.

Звучит как "масло-маслянное" на первый взгляд. Но это не так. Попробуйте
прочитать первое предложение еще раз вдумчиво и поймете что это не так.
Кстати, если вы вспомнили после второго прочтения слово
"метапрограммирование" - забудьте.

<ЛирическоеОтступление>

К этой задаче и этому языку метапрограммирование - не имеет отношения.
Я, вообще, слабо представляю метапрограммирование на 1С. Может быть в 1С
версии языка 100500 и появятся макросы, функции как объекты первого
класса, замыкания и прочие вкусные плюшки, но пока потолок
метапрограммирования - Выполнить() /Вычислить() .         Меня, как
разработчика,  это безмерно огорчает, но нет времени/денег/сил на
разработку своего компилятора 1С.         Так что буду ждать милости от
разработчиков. Может наигравшись с "Такси" - обратят внимание на язык.

</ЛирическоеОтступление>

### 3.4. А что там под капотом?


### 3.5. Вкалывают роботы, а не человек!


### 3.6. Отключим мозг - включим фантазию


### 3.7. Лень - высшая форма труда


### 3.8. Что получилось? Вариант 1


### 3.9. А если подумать? Вариант 2


### 3.10. Пример использования - markdown


### 3.11. Еще немного косметики - v8Unpack


## 4. Парсер языка запросов для 1С


## 5. А что дальше?


## 6. Пару слов в заключении

