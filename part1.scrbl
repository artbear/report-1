#lang scribble/doc
@(require scribble/core) 
@(require scribble/manual)
@(require scribble/bnf)
@(require "lang/lexer.scm")
@(define (todo . s)
   (let [(text (list (string-append "TODO " (car s))))]
     (red-text text))) 
@(define (green-text . s)
   @italic[@elem[s #:style (style #f (list (color-property "green")))]]) 
@(define (black-text . s)
   @elem[s #:style (style #f (list (color-property "black")))]) 
@(define (red-text . s)
   @elem[s #:style (style #f (list (color-property "red")))]) 
@(define (blue-text . s)
   @elem[s #:style (style #f (list (color-property "blue")))]) 
@(define (1C-colorize x y)
   (cond 
     [(keyword?  x) (red-text (string-titlecase y))]
     [(eq? 'tknID x) (blue-text y)]
     [(eq? 'tknSTRING x) (black-text (string-append "\"" y "\""))]
     [(eq? 'tknNUMBER x) (black-text y)]
     [(eq? 'tknWS x) (hspace (string-length y))]
     [(eq? 'tknNL x) (linebreak)]
     [(eq? 'tknSQEUENCE x) (green-text y)]
     [else  (red-text y)]))

@(define (1C . s)
   (let [(token-list (lex->list s))]
     (map (lambda (x) (1C-colorize (car x) (cadr x))) token-list))) 
@title[#:version "0.1"
                 #:date "2014-11-24"]{Разработка синтаксического анализатора языка запросов на языке 1С}
@(author+email "Бомбин Валентин" "wwall@yandex.ru" #:obfuscate? #t)
@;----@local-table-of-contents[]
@section{Введение}
@subsection{Благодарности}
@para{Эта статья никогда не увидела бы свет, если бы не поддержка моей жены - Людмилы. Мой ласковый ангел, эту статью я посвящаю тебе и твоему терпению.}
@subsection{О чем пойдет речь?}
@para{В этой статье будет рассмотрен один из вариантов реализации генератора синтаксических анализаторов. 
      Предложенный вариант один из многих, его не следует рассматривать как единственно возможный, 
      а только как источник идей для разработки собственных анализаторов. 
      Основной целью разработки будет получить парсер  для разбора текста запроса, но в учебных целях будет также разработано несколько анализаторов для других простых языков}
@subsection{Что надо знать, перед тем как приступить к чтению?}
@para{Для понимания статьи достаточно знать язык и среду 1С на среднем уровне. 
      Единственную сложность может вызвать использование операторов @1C{Выполнить()} и @1C{Вычислить()}.}
@para{Если использование этих конструкций вызывает у вас сложности, обратитесь к официальной документации}
@subsection{Как связаться с автором}
@para{Если вы заметили неточность, или у вас есть предложения по улучшению, вы можете написать мне письмо на мой почтовый ящик. Адрес указан вверху страницы}
@section{Необязательные инструменты использованные в процессе разработки }
@para{При разработке кода будут использоваться следующие инструменты:}
@itemize[
         @item{
               @para{Система юниттестирования xUnitFor1C.
                     Так как задача разбора текста достаточно хорошо формализуется, то для упрощения разработки будет использована достаточно развитая система @link["https://github.com/xDrivenDevelopment/xUnitFor1C"]{xUnitFor1C}.
                     Внимание, эта статья - не инструкция по применению подсистемы юнит-тестирования, поэтому все вопросы касательно функционирования и возможностей использования, пожалуйста, адресуйте разработчикам. }
                @para{Согласно методологии TDD сперва пишется тест, затем код. В этой статье при разработке модели будет применен другой подход – тест является информацией как использовать тот или иной метод. Классический TDD будет продемонстрирован при разработке учебных анализаторов.}}
          @item{
                @para{@link["https://snegopat.ru/downloads/"]{Снегопат}. Думаю, не нуждается в рекламе, пользуясь случаем, хочу сказать Александру огромное спасибо за возможность скачивать бесплатные версии}}
          @item{@para{Статья написана с помощью системы генерации текста Scribble (входит в состав DrRacket, скачать можно здесь - @url{http://racket-lang.org/download/}, исходный код статьи - @link["https://github.com/wwall/report-1"]{здесь})}}
          ]
@section{Введение}
@subsection{Примитивный синтаксический анализатор}
@para{
      Классификация парсеров и типы алгоритмов поверхностно описаны в вики 
      @link["https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7"]{Синтаксический анализ}
      В этой статье  буду описывать процесс построения парсера по алгоритму нисходящего разбора, как это описано в статье 
      @link["https://ru.wikipedia.org/wiki/%D0%93%D1%80%D0%B0%D0%BC%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0,_%D1%80%D0%B0%D0%B7%D0%B1%D0%B8%D1%80%D0%B0%D1%8E%D1%89%D0%B0%D1%8F_%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5"]{PEG}
      После того как будут описаны все необходимые примитивы, будет разработана система генерации парсеров на основании простого текстового представления}
@para{Парсер, с точки зрения PEG это функция, принимающая на вход строку и возвращающая либо успех, либо неудача. Самый простой способ задать определения успеха/неудачи следующий - }
@itemize[
         @item{
@para{Для успешного разбора - функция возвращает обработанные данные (это может быть как и прочатнный символ/символы, так и произвольные данные), а также остаток строки, получившися после работы парсера. Код выглядит так - }
@para{@1C{
    Функция РазобраноУспешно(Значение, Остаток)
        СтруктураВозврата = Новый Структура;
        СтруктураВозврата.Вставить("Тип",1);
        СтруктураВозврата.Вставить("Значение",Значение);
        СтруктураВозврата.Вставить("Остаток",Остаток);
        Возврат СтруктураВозврата;
    КонецФункции
    }}}
         @item{
               @para{В случае если функция не смогла разобрать входную строку, то возвращается структура с типом ошибки и неизмененной строкой}
@para{@1C{
    Функция РазобраноНеудачно(Остаток)
        СтруктураВозврата = Новый Структура;
        СтруктураВозврата.Вставить("Тип",0);
        СтруктураВозврата.Вставить("Остаток",Остаток);
        Возврат СтруктураВозврата;
    КонецФункции
    }}}]
@para{Тогда определение функции разбора  одного символа можно описать так}
@1C{
    Функция ПарсерОдногоСимвола(Образец,СтрокаАнализа)
        СимволАнализа = Сред(СтрокаАнализа,1,1);
        Если СимволАнализа = Образец Тогда
            Возврат РазобраноУспешно(СимволАнализа,Сред(СтрокаАнализа,2));
        Иначе
            Возврат РазобраноНеудачно(СтрокаАнализа);
        КонецЕсли;
    КонецФункции}
@para{Для проверки работоспособности кода  определим 2 теста}
@para{@1C{
    Перем юТест;}}
@para{@1C{
    Функция ПолучитьСписокТестов(ЮнитТестирование) Экспорт
        юТест = ЮнитТестирование;
        ВсеТесты = Новый Массив;
        ВсеТесты.Добавить("Тест_ОдинСимволУспешно");
        ВсеТесты.Добавить("Тест_ОдинСимволНеудачно");
        Возврат ВсеТесты;
    КонецФункции}}
@para{@1C{
    Процедура Тест_АтомарныйУспешно() экспорт
        образец = новый структура("Тип,Значение,Остаток",1,"м","ама");
        результат = ПарсерОдногоСимвола("м","мама");
        юТест.ПроверитьРавенство(результат.Тип, образец.Тип);
        юТест.ПроверитьРавенство(результат.Значение, образец.Значение);
        юТест.ПроверитьРавенство(результат.Остаток, образец.Остаток);
    КонецПроцедуры}}
@para{@1C{
    Процедура Тест_АтомарныйНеудачно() экспорт
        образец = Новый структура("Тип,Остаток",0,"мама");
        результат = ПарсерОдногоСимвола("М","мама");
        юТест.ПроверитьРавенство(результат.Тип, образец.Тип);
        юТест.ПроверитьРавенство(результат.Остаток, образец.Остаток);
    КонецПроцедуры}}
@para{Если вы используете Снегопат, то запуск тестов можно произвести прямо в конфигураторе (с помощью скрипта xddTestRunner.js), иначе вам необходимо запустить 1С в режиме предприятия, и с помощью обработки xddTestRunner.epf проверить выполнение тестов. 
      Определенные нами 2 теста отработают вполне корректно и результат тестирования будет положительным.}
@subsection{Разработка модели}
@para{Как следует из документации, последовательность парсеров - это комбинация 2 парсеров, работающая следующим образом -}
@itemize[
         @item{
               @para{1. Получить результат работы первого парсера}}
          @item{
                @para{2. Если результат работы - неудача, то парсер завершает работу и возвращает неудача}}
          @item{
                @para{3. Проверяется результат работы второго парсера}}
          @item{
                @para{4. Если результат работы - неудача, то парсер завершает работу и возвращает неудача}}
          @item{
                @para{5. Оба парсера завершены успешно, возвращается истина}}]
@para{Попытаемся реализовать это описание в виде функции}
@para{@1C{
          Функция ПоследовательностьПарсеров(Первый,Второй,СтрокаАнализа)
              РезультатРаботыПарсера = ~вызвать первый парсер~;
              Если Неудача(Первый) Тогда
                  Возврат РазобраноНеудачно(СтрокаАнализа);
              КонецЕсли;
              РезультатРаботыПарсера = ~вызвать второй парсер~;
              Если Неудача(Первый) Тогда
                  Возврат РазобраноНеудачно(СтрокаАнализа);
              КонецЕсли;
              Возврат РазобраноУспешно(~Что вернуть?~,~Как получить остаток строки?~);
          КонецФункции}}
@para{Простая на вид функция поставила перед нами столько вопросов. 
      Будем решать их последовательно. И первое к чему приступим - проектирование структуры нашего парсера.}
@para{Для начала - определимся с режимами, в которых будет существовать наш парсер. В проектируемой модели будет 2 режима - 
      режим компиляции и режим выполнения .
      Во время компиляции мы будем строить парсер, во время выполнения - разбирать полученную строку с помощью парсера}
@para{В нашей реализации парсер будет представляться структурой с обязательным полем "Тип" и списком аргументов которые будут применяться для каждого типа парсера
      Возможная реализация функции ПостроитьПарсер приведена ниже}
@para{@1C{
    Функция ПостроитьПарсер(Тип,Аргумент1 = Неопределено, Аргумент2 = Неопределено)
        Если Тип = "match" Тогда
            Возврат Новый Структура("Тип,Образец",Тип,Аргумент1);
        Иначе
            ВызватьИсключение "Неизвестный тип построения парсера """+Тип+"""";
        КонецЕсли;
    КонецФункции
    }}
@para{А функция применения парсера может тогда выглядит так}
@para{@1C{    
    Функция ПрименитьПарсер(Парсер, СтрокаАнализа)
        Если Парсер.Тип = "match" Тогда
            Возврат ПарсерОдногоСимвола(Парсер.Образец,СтрокаАнализа);
        Иначе
            ВызватьИсключение "Неизвестный тип для приеменения парсера """+Парсер.Тип+"""";
        КонецЕсли;
    КонецФункции}}
@para{Напоминаю - не обязательно именно такое определение, в своем парсере вы можете использовать любые другие варианты.}
@para{Тест для проверки и документирования варианта вызова - }
@para{@1C{    
    Процедура Тест_АтомарныйУдачноНоваяМодель() Экспорт
        Парсер = ПостроитьПарсер("match","м");
        Результат = ПрименитьПарсер(Парсер,"мама");
        Образец = РазобраноУспешно("м","ама");
        юТест.ПроверитьРавенство(Результат.Тип, образец.Тип);
        юТест.ПроверитьРавенство(Результат.Остаток, образец.Остаток);
        юТест.ПроверитьРавенство(Результат.Значение, образец.Значение);
    Конецпроцедуры 
    }}
@para{Теперь наша функция для построения последовательности, выглядит так }
@para{@1C{
    Функция ПоследовательностьПарсеров(Первый,Второй,СтрокаАнализа)
        РезультатРаботыПарсера1 = ПрименитьПарсер(Первый,СтрокаАнализа);
        Если Неудача(РезультатРаботыПарсера1) Тогда
            Возврат РазобраноНеудачно(СтрокаАнализа);
        КонецЕсли;
        РезультатРаботыПарсера2 = ПрименитьПарсер(Второй,~Как получить остаток строки после первого парсера?~);
        Если Неудача(РезультатРаботыПарсера2) Тогда
            Возврат РазобраноНеудачно(СтрокаАнализа);
        КонецЕсли;
        Возврат РазобраноУспешно(~Что вернуть?~,~Как получить остаток строки?~);
    КонецФункции}}
@para{В коде используется неопределенная функция @1C{Неудача()}. Она, как и прочие сервисные функции, для обработки результата парсера описаны ниже.}
@para{@1C{
    Функция кнстНеудача()
        Возврат 0;
    КонецФункции
}}
@para{@1C{
    Функция кнстУспех()
        Возврат 1;
    КонецФункции
}}    
@para{@1C{
    Функция РазобраноУспешно(Значение,Остаток)
        СтруктураВозврата = Новый Структура;
        СтруктураВозврата.Вставить("Тип",кнстУспех());
        СтруктураВозврата.Вставить("Значение",Значение);
        СтруктураВозврата.Вставить("Остаток",Остаток);
        Возврат СтруктураВозврата;
    КонецФункции}}    
@para{@1C{
    Функция РазобраноНеудачно(Остаток)
        СтруктураВозврата = Новый Структура;
        СтруктураВозврата.Вставить("Тип",кнстНеудача());
        СтруктураВозврата.Вставить("Остаток",Остаток);
        Возврат СтруктураВозврата;
    КонецФункции}}
@para{@1C{
    Функция Успех(Значение)
        Возврат 
            ТипЗнч(Значение) = Тип("Структура") 
            И Значение.Свойство("Тип") 
            И Значение.Тип = кнстУспех();
    КонецФункции}}
@para{@1C{
    Функция Неудача(Значение)
        Возврат 
            ТипЗнч(Значение) = Тип("Структура") 
            И Значение.Свойство("Тип") 
            И Значение.Тип = кнстНеудача();
    КонецФункции}}
@para{@1C{    
    Функция Остаток(Значение)
        Если не (Успех(Значение) 
            или Неудача(Значение)) Тогда
            ВызватьИсключение "Неверное определение структуры парсера"
        КонецЕсли;
        Возврат Значение.Остаток;
    КонецФункции}}
@para{@1C{    
    Функция Значение(Значение)
        Если не (Успех(Значение) 
            и Значение.Свойство("Значение")) Тогда
            ВызватьИсключение "Неверное определение структуры парсера"
        КонецЕсли;
        Возврат Значение.Значение;
    КонецФункции
    }}
@para{С учетом введенных функций, наша функция комбинации последовательности принимает вид}
@1C{
    Функция ПоследовательностьПарсеров(Первый,Второй,СтрокаАнализа)
        РезультатРаботыПарсера1 = ПрименитьПарсер(Первый,СтрокаАнализа);
        Если Неудача(РезультатРаботыПарсера1) Тогда
            Возврат РазобраноНеудачно(СтрокаАнализа);
        КонецЕсли;
        РезультатРаботыПарсера2 = ПрименитьПарсер(Второй,Остаток(РезультатРаботыПарсера1));
        Если Неудача(РезультатРаботыПарсера2) Тогда
            Возврат РазобраноНеудачно(СтрокаАнализа);
        КонецЕсли;
        Возврат РазобраноУспешно(~Что вернуть?~,Остаток(РезультатРаботыПарсера2));
    КонецФункции}
@para{Осталось определиться, что будет возвращать эта функция. Нам необходимо вернуть оба результата работы парсеров, и самым простым способом будет вернуть массив.
      В итоге функция принимает вид
      }
@1C{
    Функция ПоследовательностьПарсеров(Первый,Второй,СтрокаАнализа)
        РезультатРаботыПарсера1 = ПрименитьПарсер(Первый,СтрокаАнализа);
        Если Неудача(РезультатРаботыПарсера1) Тогда
            Возврат РазобраноНеудачно(СтрокаАнализа);
        КонецЕсли;
        РезультатРаботыПарсера2 = ПрименитьПарсер(Второй,Остаток(РезультатРаботыПарсера1));
        Если Неудача(РезультатРаботыПарсера2) Тогда
            Возврат РазобраноНеудачно(СтрокаАнализа);
        КонецЕсли;
        МассивВозврата = Новый Массив;
        МассивВозврата.Добавить(Значение(РезультатРаботыПарсера1));
        МассивВозврата.Добавить(Значение(РезультатРаботыПарсера2));
        Возврат РазобраноУспешно(МассивВозврата,Остаток(РезультатРаботыПарсера2));
    КонецФункции}
@para{Напишем простой тест для проверки тестовой грамматики}
@BNF[(list @nonterm{ТестоваяГрамматика}
           @BNF-seq[@nonterm{м} @nonterm{а}])
     (list @nonterm{м} @litchar{м})
     (list @nonterm{а} @litchar{а})]
@1C{    
    Процедура Тест_Последовательно() Экспорт
        БукваМ = ПостроитьПарсер("match","м");
        БукваА = ПостроитьПарсер("match","а");
        Результат = ПоследовательностьПарсеров(БукваМ,БукваА,"мама");
        МассивРезультата = Новый Массив;
        МассивРезультата.Добавить("м");
        МассивРезультата.Добавить("а");
        Образец = РазобраноУспешно(МассивРезультата,"ма");
        юТест.ПроверитьРавенство(Результат.Тип, образец.Тип);
        юТест.ПроверитьРавенство(Остаток(Результат), Остаток(образец));
        юТест.ПроверитьРавенство(Значение(Результат)[0], Значение(образец)[0]);
        юТест.ПроверитьРавенство(Значение(Результат)[1], Значение(образец)[1]);
    Конецпроцедуры
    }
@para{Если вы что-то недопоняли -пройдитесь по коду с отладчиком, потому как этот подход будет дальше использован, будет развиваться и усложняться. Другими словами - код приведенный выше - самый сложный момент на всю публикацию. Его надо понять, что бы дальнейшие рассуждения не стали "китайской грамотой".}
@para{Второй возможный вариант - разработать другую систему компиляции/интерпретации парсеров. Но это находиться вне рамок этой публикации}
@subsection{Комбинации парсеров}
@subsubsection{Последовательность: e@subscript{1} e@subscript{2} }
@para{В предыдущем параграфе мы разработали функцию парсера последовательности из 2 парсеров. Но 2 парсера в последовательности - не самый частый случай в практике, чаще последовательность содержит куда больше элементов.}
@para{Изменим представление для хранения списка парсеров в последовательности. Для этого используем массив}
@1C{
    Функция ПоследовательностьПарсеров(ПоследовательностьПарсеров,СтрокаАнализа)
    МассивВозврата = Новый Массив;
    СтрокаРаботы = СтрокаАнализа;
    Для Каждого Парсер Из ПоследовательностьПарсеров Цикл
    РезультатРаботы = ПрименитьПарсер(Парсер,СтрокаРаботы);
    Если Неудача(РезультатРаботы) Тогда
    Возврат РазобраноНеудачно(СтрокаАнализа);
    Конецесли;
    МассивВозврата.Добавить(Значение(РезультатРаботы));
    СтрокаРаботы = Остаток(РезультатРаботы);
    Конеццикла;
    Возврат РазобраноУспешно(МассивВозврата,СтрокаРаботы);
    Конецфункции 
    Функция ПостроитьПарсер(Тип,Аргумент1 = Неопределено, Аргумент2 = Неопределено)
    Если Тип = "match" Тогда
    Возврат Новый Структура("Тип,Образец",Тип,Аргумент1);
    Иначеесли Тип = "seq" Тогда
    Возврат Новый Структура("Тип,Последовательность",Тип,Аргумент1);
    Иначе
    Вызватьисключение "Неизвестный тип построения парсера """+Тип+"""";
    Конецесли;
    Конецфункции 
    Функция ПрименитьПарсер(Парсер, СтрокаАнализа)
    Если Парсер.Тип = "match" Тогда
    Возврат ПарсерОдногоСимвола(Парсер.Образец,СтрокаАнализа);
    Иначеесли Парсер.Тип = "seq" Тогда
    Возврат ПоследовательностьПарсеров(Парсер.Последовательность,СтрокаАнализа);
    Иначе
    Вызватьисключение "Неизвестный тип для приеменения парсера """+Парсер.Тип+"""";
    Конецесли;
    Конецфункции 
    }
@para{Проверим работоспособность парсера последовательности на следующей грамматике}
@BNF[(list @nonterm{тест1}
           @BNF-seq[@nonterm{м} @nonterm{а} @nonterm{м} @nonterm{а}])
     (list @nonterm{м} @litchar{м})
     (list @nonterm{а} @litchar{а})]
@1C{    
    Процедура Тест_Последовательно() Экспорт
    БукваМ = ПостроитьПарсер("match","м");
    БукваА = ПостроитьПарсер("match","а");
    МассивПарсеров = Новый Массив;
    МассивПарсеров.Добавить(БукваМ);
    МассивПарсеров.Добавить(БукваА);
    МассивПарсеров.Добавить(БукваМ);
    МассивПарсеров.Добавить(БукваА);
    ТестовыйПарсер = ПостроитьПарсер("seq",МассивПарсеров);
    Результат = ПрименитьПарсер(ТестовыйПарсер,"мама");
    МассивРезультата = Новый Массив;
    МассивРезультата.Добавить("м");
    МассивРезультата.Добавить("а");
    МассивРезультата.Добавить("м");
    МассивРезультата.Добавить("а");
    Образец = РазобраноУспешно(МассивРезультата,"");
    юТест.ПроверитьРавенство(Результат.Тип, образец.Тип);
    юТест.ПроверитьРавенство(Остаток(Результат), Остаток(образец));
    юТест.ПроверитьРавенство(Значение(Результат)[0], Значение(образец)[0]);
    юТест.ПроверитьРавенство(Значение(Результат)[1], Значение(образец)[1]);
    юТест.ПроверитьРавенство(Значение(Результат)[2], Значение(образец)[2]);
    юТест.ПроверитьРавенство(Значение(Результат)[3], Значение(образец)[3]);
    Конецпроцедуры 
    }
@para{Как и ожидалось - тест отрабатывает успешно, но чисто с эстетической точки зрения последовательность кода }
@1C{    
    МассивПарсеров = Новый Массив;
    МассивПарсеров.Добавить(БукваМ);
    МассивПарсеров.Добавить(БукваА);
    МассивПарсеров.Добавить(БукваМ);
    МассивПарсеров.Добавить(БукваА);}
@para{выглядит некрасиво. Давайте преобразуем эти строки в вызов функции @1C{ВМассив(БукваМ,БукваА,БукваМ,БукваА)}}
@1C{    
    Функция ДобавитьВМассив(МассивДобавления,Элемент)
    Если Элемент = Неопределено Тогда
    Возврат МассивДобавления;
    Конецесли;
    МассивДобавления.Добавить(Элемент);
    Конецфункции
    Функция ВМассив(Элемент1=Неопределено,Элемент2=Неопределено,Элемент3=Неопределено,Элемент4=Неопределено,Элемент5=Неопределено,Элемент6=Неопределено)
    ~// Согласен, что выглядит некрасиво, но 1С - не lisp, приходится терпеть вот такую ерунду. ~
    МассивВозврата = Новый Массив;
    Для х = 1 По 6 Цикл
    ДобавитьВМассив(МассивВозврата,Вычислить("Элемент"+х))
    Конеццикла;
    Возврат МассивВозврата;
    Конецфункции 
    }
@para{Если однажды нам не хватить аргументов в функции ВМассив, мы всегда можем расширить список,  добавив необходимое число аргументов в объявление функции.
      После такого изменения тест можно переписать, например, так}
@1C{    
    Процедура Тест_Последовательно() экспорт
    БукваМ = ПостроитьПарсер("match","м");
    БукваА = ПостроитьПарсер("match","а");
    ТестовыйПарсер = ПостроитьПарсер("seq",ВМассив(БукваМ,БукваА,БукваМ,БукваА));
    Результат = ПрименитьПарсер(ТестовыйПарсер,"мама");
    МассивРезультата = ВМассив("м","а","м","а");
    Образец = РазобраноУспешно(МассивРезультата,"");
    юТест.ПроверитьРавенство(Результат.Тип, образец.Тип);
    юТест.ПроверитьРавенство(Остаток(Результат), Остаток(образец));
    юТест.ПроверитьРавенство(Значение(Результат)[0], Значение(образец)[0]);
    юТест.ПроверитьРавенство(Значение(Результат)[1], Значение(образец)[1]);
    юТест.ПроверитьРавенство(Значение(Результат)[2], Значение(образец)[2]);
    юТест.ПроверитьРавенство(Значение(Результат)[3], Значение(образец)[3]);
    Конецпроцедуры 
    }
@subsubsection{Упорядоченный выбор: e@subscript{1} / e@subscript{2}}
@para{ Рассмотрим определение для операции выбора - Оператор выбора e@subscript{1} / e@subscript{2} сначала вызывает e@subscript{1} и, если e@subscript{1} успешно,
                                                                     возвращает её результат. Иначе, если e@subscript{1} проваливается, оператор выбора восстанавливает входную строку в состояние, предшествующее вызову 
                                                                     e@subscript{1}, и вызывает e@subscript{2}, возвращая её результат.}
@para{Код парсера для 2 аргументов выглядит так}
@1C{
    Функция ОперацияВыбор(Первый,Второй,СтрокаАнализа)
    РезультатРаботыПарсера1 = ПрименитьПарсер(Первый,СтрокаАнализа);
    Если Успех(РезультатРаботыПарсера1) Тогда
    Возврат РезультатРаботыПарсера1;
    КонецЕсли;
    
    Возврат ПрименитьПарсер(Второй,СтрокаАнализа);
    КонецФункции}
@para{Расширим определение оператора выбора таким образом - Оператор выбора последовательно применяет входящие в его состав альтернативы до тех пор, пока не встретиться парсер вернувший Успех() или не будут просмотрены все альтернативы. Возвращает значение первого успешного парсера и завершает свою работу или значение вычисления последней альтернативы}
@para{В нашем коде реализовано это будет так}
@1C{
    Функция ОперацияВыбор(ПоследовательностьПарсеров,СтрокаАнализа)
    Для Каждого Парсер из ПоследовательностьПарсеров цикл
    РезультатРаботы = ПрименитьПарсер(Парсер,СтрокаАнализа);
    Если Успех(РезультатРаботы) Тогда
    Возврат РезультатРаботы
    КонецЕсли;
    КонецЦикла;
    Возврат РезультатРаботы;
    КонецФункции}
@para{Добавим определение оператора выбора в функции @1C{ПостроитьПарсер()} и @1C{ПрименитьПарсер}}
@1C{Функция ПостроитьПарсер(Тип,Аргумент1 = Неопределено, Аргумент2 = Неопределено)
    Если Тип = "match" Тогда
    Возврат Новый Структура("Тип,Образец",Тип,Аргумент1);
    ИначеЕсли Тип = "seq" Тогда
    Возврат Новый Структура("Тип,Последовательность",Тип,Аргумент1);
    ИначеЕсли Тип = "/" Тогда
    Возврат Новый Структура("Тип,Последовательность",Тип,Аргумент1);
    Иначе
    ВызватьИсключение "Неизвестный тип построения парсера """+Тип+"""";
    КонецЕсли;
    КонецФункции
    }
@1C{    
    Функция ПрименитьПарсер(Парсер, СтрокаАнализа)
    Если Парсер.Тип = "match" Тогда
    Возврат ПарсерОдногоСимвола(Парсер.Образец,СтрокаАнализа);
    ИначеЕсли Парсер.Тип = "seq" Тогда
    Возврат ПоследовательностьПарсеров(Парсер.Последовательность,СтрокаАнализа);
    ИначеЕсли Парсер.Тип = "/" Тогда
    Возврат ОперацияВыбор(Парсер.Последовательность,СтрокаАнализа);
    Иначе
    ВызватьИсключение "Неизвестный тип для приеменения парсера """+Парсер.Тип+"""";
    КонецЕсли;
    КонецФункции}
@para{Традиционно закончим работу с новым оператором простым тестом для грамматики}
@BNF[(list @nonterm{тест1}
           @BNF-seq[@nonterm{М/П} @nonterm{А} @nonterm{М/П} @nonterm{А}])
     (list @nonterm{М/П} @BNF-alt[ @litchar{м} @litchar{п}])
     (list @nonterm{А} @litchar{а})]
@1C{    
    Процедура Тест_ОперацияВыбор() Экспорт
    БукваМ = ПостроитьПарсер("match","м");
    БукваП = ПостроитьПарсер("match","п");
    БукваА = ПостроитьПарсер("match","а");
    БукваМилиП = ПостроитьПарсер("/",ВМассив(БукваМ,БукваП));
    ТестовыйПарсер = ПостроитьПарсер("seq",ВМассив(БукваМилиП,БукваА,БукваМилиП,БукваА));
    Результат = ПрименитьПарсер(ТестовыйПарсер,"папа");
    МассивРезультата = ВМассив("п","а","п","а");
    Образец = РазобраноУспешно(МассивРезультата,"");
    юТест.ПроверитьРавенство(Результат.Тип, образец.Тип);
    юТест.ПроверитьРавенство(Остаток(Результат), Остаток(образец));
    юТест.ПроверитьРавенство(Значение(Результат)[0], Значение(образец)[0]);
    юТест.ПроверитьРавенство(Значение(Результат)[1], Значение(образец)[1]);
    юТест.ПроверитьРавенство(Значение(Результат)[2], Значение(образец)[2]);
    юТест.ПроверитьРавенство(Значение(Результат)[3], Значение(образец)[3]);
    Конецпроцедуры}
@para{Запустим его, удостоверимся что все работает и перейдем к следующему этапу.}
@subsubsection{Один или более (e+), нуль или более (e*),  необязательно (e?)}
@para{Как и ранее, возьмем определения для операторов с wiki - Операторы нуль-или-более, один-или-более и необязательности поглощают соответственно нуль или более, одно или более, или нуль либо одно последовательное появление своего подвыражения e. В отличие от КС-грамматик и регулярных выражений, эти операторы всегда являются жадными, и поглощают столько входных экземпляров, сколько могут.}
@para{И переведем каждый из этик операторов в код (как видите в написании парсеров нет ничего сложного - читай постановку задачи и пиши код)}
@para{Парсер "Один или более" можно определить так}
@1C{
    Функция ОдинИлиБолее(Парсер,СтрокаАнализа)
    СтрокаРаботы = СтрокаАнализа;
    МассивРезультата = Новый Массив;
    Пока Истина Цикл
    Результат = ПрименитьПарсер(Парсер,СтрокаРаботы);
    Если Неудача(Результат) тогда
    Прервать;
    КонецЕсли;
    МассивРезультата.Добавить(Значение(Результат));
    СтрокаРаботы = Остаток(Результат);
    КонецЦикла;
    Если МассивРезультата.Количество() = 0 Тогда
    Возврат РазобраноНеудачно(СтрокаАнализа);
    Иначе
    Возврат РазобраноУспешно(МассивРезультата,СтрокаРаботы);
    КонецЕсли;
    КонецФункции
    }
@para{Изменим функции ПостроитьПарсер и ПрименитьПарсер}
@1C{    
    Функция ПостроитьПарсер(Тип,Аргумент1 = Неопределено, Аргумент2 = Неопределено)
    Если Тип = "match" Тогда
    Возврат Новый Структура("Тип,Образец",Тип,Аргумент1);
    ИначеЕсли Тип = "seq" Тогда
    Возврат Новый Структура("Тип,Последовательность",Тип,Аргумент1);
    ИначеЕсли Тип = "/" Тогда
    Возврат Новый Структура("Тип,Последовательность",Тип,Аргумент1);
    ИначеЕсли Тип = "+" Тогда
    Возврат Новый Структура("Тип,Парсер",Тип,Аргумент1);
    Иначе
    ВызватьИсключение "Неизвестный тип построения парсера """+Тип+"""";
    КонецЕсли;
    КонецФункции
    Функция ПрименитьПарсер(Парсер, СтрокаАнализа)
    Если Парсер.Тип = "match" Тогда
    Возврат ПарсерОдногоСимвола(Парсер.Образец,СтрокаАнализа);
    ИначеЕсли Парсер.Тип = "seq" Тогда
    Возврат ПоследовательностьПарсеров(Парсер.Последовательность,СтрокаАнализа);
    ИначеЕсли Парсер.Тип = "/" Тогда
    Возврат ОперацияВыбор(Парсер.Последовательность,СтрокаАнализа);
    ИначеЕсли Парсер.Тип = "+" Тогда
    Возврат  ОдинИлиБолее(Парсер.Парсер,СтрокаАнализа);
    Иначе
    ВызватьИсключение "Неизвестный тип для приеменения парсера """+Парсер.Тип+"""";
    КонецЕсли;
    КонецФункции}
@para{Напишем тест. Кстати, обратите внимание, оператор "+" возвращает массив с результатами работы вложенного парсера. }
@1C{
    Процедура Тест_ОдинИлиБолее_Один() Экспорт
    БукваМ = ПостроитьПарсер("match","м");
    БукваА = ПостроитьПарсер("match","а");
    БукваМиА = ПостроитьПарсер("seq",ВМассив(БукваМ,БукваА));
    ТестовыйПарсер = ПостроитьПарсер("+",БукваМиА);
    Результат = ПрименитьПарсер(ТестовыйПарсер,"ма");
    МассивРезультата = ВМассив(ВМассив("м","а"));
    Образец = РазобраноУспешно(МассивРезультата,"");
    юТест.ПроверитьРавенство(Результат.Тип, образец.Тип);
    юТест.ПроверитьРавенство(Остаток(Результат), Остаток(образец));
    юТест.ПроверитьРавенство(Значение(Результат)[0][0], Значение(образец)[0][0]);
    юТест.ПроверитьРавенство(Значение(Результат)[0][1], Значение(образец)[0][1]);
    Конецпроцедуры
    Процедура Тест_ОдинИлиБолее_Более() Экспорт
    БукваМ = ПостроитьПарсер("match","м");
    БукваП = ПостроитьПарсер("match","п");
    БукваА = ПостроитьПарсер("match","а");
    БукваМиА = ПостроитьПарсер("seq",ВМассив(БукваМ,БукваА));
    ТестовыйПарсер = ПостроитьПарсер("+",БукваМиА);
    Результат = ПрименитьПарсер(ТестовыйПарсер,"мама");
    МассивРезультата = ВМассив(ВМассив("м","а"),ВМассив("м","а"));
    Образец = РазобраноУспешно(МассивРезультата,"");
    юТест.ПроверитьРавенство(Результат.Тип, образец.Тип);
    юТест.ПроверитьРавенство(Остаток(Результат), Остаток(образец));
    юТест.ПроверитьРавенство(Значение(Результат)[0][0], Значение(образец)[0][0]);
    юТест.ПроверитьРавенство(Значение(Результат)[0][1], Значение(образец)[0][1]);
    юТест.ПроверитьРавенство(Значение(Результат)[1][0], Значение(образец)[1][0]);
    юТест.ПроверитьРавенство(Значение(Результат)[1][1], Значение(образец)[1][1]);
    Конецпроцедуры
    Процедура Тест_ОдинИлиБолее_Ноль() Экспорт
    БукваМ = ПостроитьПарсер("match","м");
    БукваА = ПостроитьПарсер("match","а");
    БукваМиА = ПостроитьПарсер("seq",ВМассив(БукваМ,БукваА));
    ТестовыйПарсер = ПостроитьПарсер("+",БукваМиА);
    Результат = ПрименитьПарсер(ТестовыйПарсер,"папа");
    Образец = РазобраноНеудачно("папа");
    юТест.ПроверитьРавенство(Результат.Тип, образец.Тип);
    юТест.ПроверитьРавенство(Остаток(Результат), Остаток(образец));
    Конецпроцедуры
    }
@para{Парсер "Ноль или более" определяется по аналогии с парсером "Один или более", но всегда возвращает успешный результат разбора}
@1C{    
    Функция НольИлиБолее(Парсер,СтрокаАнализа)
    СтрокаРаботы = СтрокаАнализа;
    МассивРезультата = Новый Массив;
    Пока Истина Цикл
    Результат = ПрименитьПарсер(Парсер,СтрокаРаботы);
    Если Неудача(Результат) тогда
    Прервать;
    КонецЕсли;
    МассивРезультата.Добавить(Значение(Результат));
    СтрокаРаботы = Остаток(Результат);
    КонецЦикла;
    Возврат РазобраноУспешно(МассивРезультата,СтрокаРаботы);
    КонецФункции}
@para{Изменим функции ПостроитьПарсер и ПрименитьПарсер, что бы добавить поддержку парсера "Ноль и более"}
@1C{    
    Функция ПостроитьПарсер(Тип,Аргумент1 = Неопределено, Аргумент2 = Неопределено)
    Если Тип = "match" Тогда
    Возврат Новый Структура("Тип,Образец",Тип,Аргумент1);
    ИначеЕсли Тип = "seq" Тогда
    Возврат Новый Структура("Тип,Последовательность",Тип,Аргумент1);
    ИначеЕсли Тип = "/" Тогда
    Возврат Новый Структура("Тип,Последовательность",Тип,Аргумент1);
    ИначеЕсли Тип = "+" Тогда
    Возврат Новый Структура("Тип,Парсер",Тип,Аргумент1);
    ИначеЕсли Тип = "*" Тогда
    Возврат Новый Структура("Тип,Парсер",Тип,Аргумент1);
    Иначе
    ВызватьИсключение "Неизвестный тип построения парсера """+Тип+"""";
    КонецЕсли;
    КонецФункции
    Функция ПрименитьПарсер(Парсер, СтрокаАнализа)
    Если Парсер.Тип = "match" Тогда
    Возврат ПарсерОдногоСимвола(Парсер.Образец,СтрокаАнализа);
    ИначеЕсли Парсер.Тип = "seq" Тогда
    Возврат ПоследовательностьПарсеров(Парсер.Последовательность,СтрокаАнализа);
    ИначеЕсли Парсер.Тип = "/" Тогда
    Возврат ОперацияВыбор(Парсер.Последовательность,СтрокаАнализа);
    ИначеЕсли Парсер.Тип = "+" Тогда
    Возврат  ОдинИлиБолее(Парсер.Парсер,СтрокаАнализа);
    ИначеЕсли Парсер.Тип = "*" Тогда
    Возврат  НольИлиБолее(Парсер.Парсер,СтрокаАнализа);
    Иначе
    ВызватьИсключение "Неизвестный тип для приеменения парсера """+Парсер.Тип+"""";
    КонецЕсли;
    КонецФункции}
@para{Традиционные тесты для проверки}
@1C{
    Процедура Тест_НольИлиБолее_Ноль() Экспорт
    БукваМ = ПостроитьПарсер("match","м");
    БукваА = ПостроитьПарсер("match","а");
    БукваМиА = ПостроитьПарсер("seq",ВМассив(БукваМ,БукваА));
    ТестовыйПарсер = ПостроитьПарсер("*",БукваМиА);
    Результат = ПрименитьПарсер(ТестовыйПарсер,"папа");
    МассивРезультата = новый Массив;
    Образец = РазобраноУспешно(МассивРезультата,"папа");
    юТест.ПроверитьРавенство(Результат.Тип, образец.Тип);
    юТест.ПроверитьРавенство(Остаток(Результат), Остаток(образец));
    юТест.ПроверитьРавенство(Значение(Результат).Количество(), Значение(образец).Количество());
    Конецпроцедуры
    Процедура Тест_НольИлиБолее_Более() Экспорт
    БукваМ = ПостроитьПарсер("match","м");
    БукваА = ПостроитьПарсер("match","а");
    БукваМиА = ПостроитьПарсер("seq",ВМассив(БукваМ,БукваА));
    ТестовыйПарсер = ПостроитьПарсер("*",БукваМиА);
    Результат = ПрименитьПарсер(ТестовыйПарсер,"мама");
    МассивРезультата = ВМассив(ВМассив("м","а"),ВМассив("м","а"));
    Образец = РазобраноУспешно(МассивРезультата,"");
    юТест.ПроверитьРавенство(Результат.Тип, образец.Тип);
    юТест.ПроверитьРавенство(Остаток(Результат), Остаток(образец));
    юТест.ПроверитьРавенство(Значение(Результат)[0][0], Значение(образец)[0][0]);
    юТест.ПроверитьРавенство(Значение(Результат)[0][1], Значение(образец)[0][1]);
    юТест.ПроверитьРавенство(Значение(Результат)[1][0], Значение(образец)[1][0]);
    юТест.ПроверитьРавенство(Значение(Результат)[1][1], Значение(образец)[1][1]);
    Конецпроцедуры
    }
@para{Остался последний простой оператор - Необязательно. Определим его таким образом}
@1C{    
    Функция Необязательно(Парсер,СтрокаАнализа)
    Результат = ПрименитьПарсер(Парсер,СтрокаАнализа);
    Если Успех(Результат) тогда
    Возврат Результат;
    Иначе
    Возврат РазобраноУспешно(Неопределено,СтрокаАнализа);
    КонецЕсли;
    КонецФункции
    Функция ПостроитьПарсер(Тип,Аргумент1 = Неопределено, Аргумент2 = Неопределено)
    Если Тип = "match" Тогда
    Возврат Новый Структура("Тип,Образец",Тип,Аргумент1);
    ИначеЕсли Тип = "seq" Тогда
    Возврат Новый Структура("Тип,Последовательность",Тип,Аргумент1);
    ИначеЕсли Тип = "/" Тогда
    Возврат Новый Структура("Тип,Последовательность",Тип,Аргумент1);
    ИначеЕсли Тип = "+" Тогда
    Возврат Новый Структура("Тип,Парсер",Тип,Аргумент1);
    ИначеЕсли Тип = "*" Тогда
    Возврат Новый Структура("Тип,Парсер",Тип,Аргумент1);
    ИначеЕсли Тип = "?" Тогда
    Возврат Новый Структура("Тип,Парсер",Тип,Аргумент1);
    Иначе
    ВызватьИсключение "Неизвестный тип построения парсера """+Тип+"""";
    КонецЕсли;
    КонецФункции
    Функция ПрименитьПарсер(Парсер, СтрокаАнализа)
    Если Парсер.Тип = "match" Тогда
    Возврат ПарсерОдногоСимвола(Парсер.Образец,СтрокаАнализа);
    ИначеЕсли Парсер.Тип = "seq" Тогда
    Возврат ПоследовательностьПарсеров(Парсер.Последовательность,СтрокаАнализа);
    ИначеЕсли Парсер.Тип = "/" Тогда
    Возврат ОперацияВыбор(Парсер.Последовательность,СтрокаАнализа);
    ИначеЕсли Парсер.Тип = "+" Тогда
    Возврат  ОдинИлиБолее(Парсер.Парсер,СтрокаАнализа);
    ИначеЕсли Парсер.Тип = "*" Тогда
    Возврат  НольИлиБолее(Парсер.Парсер,СтрокаАнализа);
    ИначеЕсли Парсер.Тип = "?" Тогда
    Возврат  Необязательно(Парсер.Парсер,СтрокаАнализа);
    Иначе
    ВызватьИсключение "Неизвестный тип для приеменения парсера """+Парсер.Тип+"""";
    КонецЕсли;
    КонецФункции}
@para{Конечно же, тесты. Без них – никак!}
@1C{
    Процедура Тест_Необязательно_Есть() Экспорт
    БукваМ = ПостроитьПарсер("match","м");
    БукваА = ПостроитьПарсер("match","а");
    БукваМиА = ПостроитьПарсер("seq",ВМассив(БукваМ,БукваА));
    ТестовыйПарсер = ПостроитьПарсер("?",БукваМиА);
    Результат = ПрименитьПарсер(ТестовыйПарсер,"мама");
    МассивРезультата = ВМассив("м","а");
    Образец = РазобраноУспешно(МассивРезультата,"ма");
    юТест.ПроверитьРавенство(Результат.Тип, образец.Тип);
    юТест.ПроверитьРавенство(Остаток(Результат), Остаток(образец));
    юТест.ПроверитьРавенство(Значение(Результат)[0], Значение(образец)[0]);
    юТест.ПроверитьРавенство(Значение(Результат)[0], Значение(образец)[0]);
    Конецпроцедуры
    Процедура Тест_Необязательно_Нет() Экспорт
    БукваМ = ПостроитьПарсер("match","м");
    БукваА = ПостроитьПарсер("match","а");
    БукваМиА = ПостроитьПарсер("seq",ВМассив(БукваМ,БукваА));
    ТестовыйПарсер = ПостроитьПарсер("?",БукваМиА);
    Результат = ПрименитьПарсер(ТестовыйПарсер,"папа");
    Образец = РазобраноУспешно(Неопределено,"папа");
    юТест.ПроверитьРавенство(Результат.Тип, образец.Тип);
    юТест.ПроверитьРавенство(Остаток(Результат), Остаток(образец));
    юТест.ПроверитьРавенство(Значение(Результат), Значение(образец));
    Конецпроцедуры
    }

@subsubsection{И-предикат (&e), НЕ-предикат (!e)}
@para{Что бы не изобретать велосипед и не страдать приступами оригинального (или альтернативного ) мышления, определения для операторов "&" и "!" возьмем с wiki - 
      Выражение &e вызывает подвыражение e, и возвращает успех, если e успешно, и провал в противном случае, но никогда не поглощает ввода. Аналогично, выражение !e срабатывает успешно, если e проваливается и проваливается, если e успешно, так же не поглощая ввода.}
@para{Сложностей в определении этих операторов нет. }
@1C{    
    Функция ИПредикат(Парсер,СтрокаАнализа)
    Результат = ПрименитьПарсер(Парсер,СтрокаАнализа);
    Если Успех(Результат) тогда
    Возврат РазобраноУспешно(Неопределено,СтрокаАнализа); 
    Иначе
    Возврат РазобраноНеудачно(СтрокаАнализа);
    КонецЕсли;
    КонецФункции
    }
@para{Обратите внимание - в функцию @1C{РазобраноУспешно(...)} передается входная строка, а не остаток от применения парсера.}
@para{Аналогично определяем и Не-предикат}
@1C{    
    Функция НеПредикат(Парсер,СтрокаАнализа)
    Результат = ПрименитьПарсер(Парсер,СтрокаАнализа);
    Если Неудача(Результат) тогда
    Возврат РазобраноУспешно(Неопределено,СтрокаАнализа); 
    Иначе
    Возврат РазобраноНеудачно(СтрокаАнализа);
    КонецЕсли;
    КонецФункции
    }
@para{Добавим операторы "!" и "&" в функции @1C{ПостроитьПарсер()}и @1C{ПрименитьПарсер()}}
@1C{    
    Функция ПостроитьПарсер(Тип,Аргумент1 = Неопределено, Аргумент2 = Неопределено)
    Если Тип = "match" Тогда
    Возврат Новый Структура("Тип,Образец",Тип,Аргумент1);
    ИначеЕсли Тип = "seq" Тогда
    Возврат Новый Структура("Тип,Последовательность",Тип,Аргумент1);
    ИначеЕсли Тип = "/" Тогда
    Возврат Новый Структура("Тип,Последовательность",Тип,Аргумент1);
    ИначеЕсли Тип = "+" Тогда
    Возврат Новый Структура("Тип,Парсер",Тип,Аргумент1);
    ИначеЕсли Тип = "*" Тогда
    Возврат Новый Структура("Тип,Парсер",Тип,Аргумент1);
    ИначеЕсли Тип = "?" Тогда
    Возврат Новый Структура("Тип,Парсер",Тип,Аргумент1);
    ИначеЕсли Тип = "!" Тогда
    Возврат Новый Структура("Тип,Парсер",Тип,Аргумент1);
    ИначеЕсли Тип = "&" Тогда
    Возврат Новый Структура("Тип,Парсер",Тип,Аргумент1);
    Иначе
    ВызватьИсключение "Неизвестный тип построения парсера """+Тип+"""";
    КонецЕсли;
    КонецФункции
    Функция ПрименитьПарсер(Парсер, СтрокаАнализа)
    Если Парсер.Тип = "match" Тогда
    Возврат ПарсерОдногоСимвола(Парсер.Образец,СтрокаАнализа);
    ИначеЕсли Парсер.Тип = "seq" Тогда
    Возврат ПоследовательностьПарсеров(Парсер.Последовательность,СтрокаАнализа);
    ИначеЕсли Парсер.Тип = "/" Тогда
    Возврат ОперацияВыбор(Парсер.Последовательность,СтрокаАнализа);
    ИначеЕсли Парсер.Тип = "+" Тогда
    Возврат  ОдинИлиБолее(Парсер.Парсер,СтрокаАнализа);
    ИначеЕсли Парсер.Тип = "*" Тогда
    Возврат  НольИлиБолее(Парсер.Парсер,СтрокаАнализа);
    ИначеЕсли Парсер.Тип = "?" Тогда
    Возврат  Необязательно(Парсер.Парсер,СтрокаАнализа);
    ИначеЕсли Парсер.Тип = "!" Тогда
    Возврат НеПредикат(Парсер.Парсер,СтрокаАнализа);
    ИначеЕсли Парсер.Тип = "&" Тогда
    Возврат ИПредикат(Парсер.Парсер,СтрокаАнализа);
    Иначе
    ВызватьИсключение "Неизвестный тип для приеменения парсера """+Парсер.Тип+"""";
    КонецЕсли;
    КонецФункции}
@para{И сразу тесты для проверки работы.}
@1C{
    Процедура Тест_ИПредикат() Экспорт
    БукваМ = ПостроитьПарсер("match","м");
    БукваА = ПостроитьПарсер("match","а");
    БукваМиА = ПостроитьПарсер("seq",ВМассив(БукваМ,БукваА));
    ТестовыйПарсер = ПостроитьПарсер("seq",ВМассив(БукваМиА,ПостроитьПарсер("&",БукваМ)));
    Результат = ПрименитьПарсер(ТестовыйПарсер,"мама");
    МассивРезультата = ВМассив(ВМассив("м","а"));
    Образец = РазобраноУспешно(МассивРезультата,"ма");
    юТест.ПроверитьРавенство(Результат.Тип, образец.Тип);
    юТест.ПроверитьРавенство(Остаток(Результат), Остаток(образец));
    юТест.ПроверитьРавенство(Значение(Результат)[0][0], Значение(образец)[0][0]);
    юТест.ПроверитьРавенство(Значение(Результат)[0][1], Значение(образец)[0][1]);
    Конецпроцедуры
    Процедура Тест_НеПредикат() Экспорт
    БукваМ = ПостроитьПарсер("match","м");
    БукваА = ПостроитьПарсер("match","а");
    БукваП = ПостроитьПарсер("match","а");
    БукваМиА = ПостроитьПарсер("seq",ВМассив(БукваМ,БукваА));
    ТестовыйПарсер = ПостроитьПарсер("seq",ВМассив(БукваМиА,ПостроитьПарсер("!",БукваП)));
    Результат = ПрименитьПарсер(ТестовыйПарсер,"мама");
    МассивРезультата = ВМассив(ВМассив("м","а"));
    Образец = РазобраноУспешно(МассивРезультата,"ма");
    юТест.ПроверитьРавенство(Результат.Тип, образец.Тип);
    юТест.ПроверитьРавенство(Остаток(Результат), Остаток(образец));
    юТест.ПроверитьРавенство(Значение(Результат)[0][0], Значение(образец)[0][0]);
    юТест.ПроверитьРавенство(Значение(Результат)[0][1], Значение(образец)[0][1]);
    Конецпроцедуры
    }
@subsubsection{Упростим код}
@para{Давайте посмотрим на определение функции @1C{ПостроитьПарсер(...}и @1C{ПрименитьПарсер(...)} и подумаем - как она будет расти при добавлении новых операторов? 
                                               Правильный ответ - быстро. Добавление нового оператора будет приводить к добавлению как минимум 2 строк кода и уже при 15 операторах наша функция 
                                               будет не влезать в экран, работать с ней станет сложно}
@para{Откажемся от второго аргумента в функции @1C{ПостроитьПарсер(...)} и применим паттерн "Pluggable Selector" к функции @1C{ПрименитьПарсер(...)}. Наш код  преобразуется в такой}
@1C{
    Перем СписокФункций;
    Функция ЗарегистрироватьФункцииПарсера(ТипПарсера,ФункцияРазбора)
    СписокФункций[ТипПарсера] = ФункцияРазбора
    КонецФункции
    Функция ПостроитьПарсер(Тип,Аргумент1 = Неопределено)
    Возврат Новый Структура("Тип,Парсер",Тип,Аргумент1);
    КонецФункции
    Функция ПрименитьПарсер(Парсер, СтрокаАнализа)
    ФункцияПарсера = СписокФункций [Парсер.Тип];
    Если СтруктураПарсера = Неопределено тогда
    ВызватьИсключение "Неизвестный тип парсера "+Парсер.Тип;
    КонецЕсли;
    Возврат Вычислить(ФункцияПарсера + "(Парсер,Строка)");
    КонецФункции
    Процедура Инициализация()
    СписокФункций = новый Соответствие;
    ЗарегистрироватьФункцииПарсера ("match", "ПарсерОдногоСимвола");
    ЗарегистрироватьФункцииПарсера ("seq", "ПоследовательностьПарсеров");
    ЗарегистрироватьФункцииПарсера ("/", "ОперацияВыбор");
    ЗарегистрироватьФункцииПарсера ("+", "ОдинИлиБолее");
    ЗарегистрироватьФункцииПарсера ("*", "НольИлиБолее");
    ЗарегистрироватьФункцииПарсера ("?", "Необязательно" , "Разобрать_альтернатива");
    ЗарегистрироватьФункцииПарсера ("!", "НеПредикат");
    ЗарегистрироватьФункцииПарсера ("&", "ИПредикат");
    КонецПроцедуры } 
@para{Учитывая что мы поменяли интерфейс вызова функций (раньше передавались аргументы, а теперь они завернуты в структуру и храняться по ключу "Парсер", тесты написаные для старой версии интерпретатора парсеров все закончатся неудачно.
      Но менять их не будем. Лучше изменим код под тесты. Новый вариант интерпретатора выглядит так }
@1C{
    Перем юТест;
    Перем СписокФункций;
    Функция ПолучитьСписокТестов(ЮнитТестирование) Экспорт
    юТест = ЮнитТестирование;
    ВсеТесты = Новый Массив;
    ВсеТесты.Добавить("Тест_Последовательно");
    ВсеТесты.Добавить("Тест_ОперацияВыбор");
    ВсеТесты.Добавить("Тест_ОдинИлиБолее_Один");
    ВсеТесты.Добавить("Тест_ОдинИлиБолее_Более");
    ВсеТесты.Добавить("Тест_ОдинИлиБолее_Ноль");
    ВсеТесты.Добавить("Тест_НольИлиБолее_Ноль");
    ВсеТесты.Добавить("Тест_НольИлиБолее_Более");
    ВсеТесты.Добавить("Тест_Необязательно_Есть");
    ВсеТесты.Добавить("Тест_Необязательно_Нет");
    ВсеТесты.Добавить("Тест_ИПредикат");
    ВсеТесты.Добавить("Тест_НеПредикат");
    Возврат ВсеТесты;
    КонецФункции
    Функция ДобавитьВМассив(МассивДобавления,Элемент)
    Если Элемент = Неопределено Тогда
    Возврат МассивДобавления;
    Конецесли;
    МассивДобавления.Добавить(Элемент);
    Конецфункции
    Функция ВМассив(Элемент1=Неопределено,Элемент2=Неопределено,Элемент3=Неопределено,Элемент4=Неопределено,Элемент5=Неопределено,Элемент6=Неопределено)
    //Выглядит некрасиво, согласен, но 1С - не lisp, приходится терпеть вот такую ерунду. 
    МассивВозврата = Новый Массив;
    Для х = 1 По 6 Цикл
    ДобавитьВМассив(МассивВозврата,Вычислить("Элемент"+х))
    Конеццикла;
    Возврат МассивВозврата;
    Конецфункции 
    Функция кнстНеудача()
    Возврат 0;
    Конецфункции
    Функция кнстУспех()
    Возврат 1;
    Конецфункции
    Функция РазобраноУспешно(Значение,Остаток)
    Возврат Новый Структура("Тип,Значение,Остаток",кнстУспех(),Значение,Остаток);
    Конецфункции
    Функция РазобраноНеудачно(Остаток)
    Возврат Новый Структура("Тип,Остаток",кнстНеудача(),Остаток);
    Конецфункции
    Функция Успех(Значение)
    Возврат ТипЗнч(Значение) = Тип("Структура") И Значение.Свойство("Тип") И Значение.Тип = кнстУспех();
    Конецфункции
    Функция Неудача(Значение)
    Возврат ТипЗнч(Значение) = Тип("Структура") И Значение.Свойство("Тип") И Значение.Тип = кнстНеудача();
    Конецфункции
    Функция Остаток(Значение)
    Если Не (Успех(Значение) Или Неудача(Значение)) Тогда
    Вызватьисключение "Неверное определение структуры парсера"
    Конецесли;
    Возврат Значение.Остаток;
    Конецфункции
    Функция Значение(Значение)
    Если Не (Успех(Значение) И Значение.Свойство("Значение")) Тогда
    Вызватьисключение "Неверное определение структуры парсера"
    Конецесли;
    Возврат Значение.Значение;
    Конецфункции
    Функция ПарсерОдногоСимвола(Парсер,СтрокаАнализа)
    СимволАнализа = Сред(СтрокаАнализа,1,1);
    Если СимволАнализа = Парсер.Парсер Тогда
    Возврат РазобраноУспешно(СимволАнализа,Сред(СтрокаАнализа,2));
    Иначе
    Возврат РазобраноНеудачно(СтрокаАнализа);
    Конецесли;
    Конецфункции
    Функция ПоследовательностьПарсеров(ПоследовательностьПарсеров,СтрокаАнализа)
    МассивВозврата = Новый Массив;
    СтрокаРаботы = СтрокаАнализа;
    Для Каждого Парсер Из ПоследовательностьПарсеров.Парсер Цикл
    РезультатРаботы = ПрименитьПарсер(Парсер,СтрокаРаботы);
    Если Неудача(РезультатРаботы) Тогда
    Возврат РазобраноНеудачно(СтрокаАнализа);
    Конецесли;
    МассивВозврата.Добавить(Значение(РезультатРаботы));
    СтрокаРаботы = Остаток(РезультатРаботы);
    Конеццикла;
    Возврат РазобраноУспешно(МассивВозврата,СтрокаРаботы);
    Конецфункции 
    Функция ОперацияВыбор(ПоследовательностьПарсеров,СтрокаАнализа)
    Для Каждого Парсер Из ПоследовательностьПарсеров.Парсер Цикл
    РезультатРаботы = ПрименитьПарсер(Парсер,СтрокаАнализа);
    Если Успех(РезультатРаботы) Тогда
    Возврат РезультатРаботы
    Конецесли;
    Конеццикла;
    Возврат РезультатРаботы;
    Конецфункции 
    Функция ОдинИлиБолее(Парсер,СтрокаАнализа)
    СтрокаРаботы = СтрокаАнализа;
    МассивРезультата = Новый Массив;
    РабочийПарсер = Парсер.Парсер;
    Пока Истина Цикл
    Результат = ПрименитьПарсер(РабочийПарсер,СтрокаРаботы);
    Если Неудача(Результат) тогда
    Прервать;
    КонецЕсли;
    МассивРезультата.Добавить(Значение(Результат));
    СтрокаРаботы = Остаток(Результат);
    КонецЦикла;
    Если МассивРезультата.Количество() = 0 Тогда
    Возврат РазобраноНеудачно(СтрокаАнализа);
    Иначе
    Возврат РазобраноУспешно(МассивРезультата,СтрокаРаботы);
    КонецЕсли;
    КонецФункции
    Функция НольИлиБолее(Парсер,СтрокаАнализа)
    СтрокаРаботы = СтрокаАнализа;
    МассивРезультата = Новый Массив;
    РабочийПарсер = Парсер.Парсер;
    Пока Истина Цикл
    Результат = ПрименитьПарсер(РабочийПарсер,СтрокаРаботы);
    Если Неудача(Результат) тогда
    Прервать;
    КонецЕсли;
    МассивРезультата.Добавить(Значение(Результат));
    СтрокаРаботы = Остаток(Результат);
    КонецЦикла;
    Возврат РазобраноУспешно(МассивРезультата,СтрокаРаботы);
    КонецФункции
    Функция Необязательно(Парсер,СтрокаАнализа)
    Результат = ПрименитьПарсер(Парсер.Парсер,СтрокаАнализа);
    Если Успех(Результат) Тогда
    Возврат Результат;
    Иначе
    Возврат РазобраноУспешно(Неопределено,СтрокаАнализа);
    Конецесли;
    Конецфункции
    Функция ИПредикат(Парсер,СтрокаАнализа)
    Результат = ПрименитьПарсер(Парсер.Парсер,СтрокаАнализа);
    Если Успех(Результат) Тогда
    Возврат РазобраноУспешно(Неопределено,СтрокаАнализа);
    Иначе
    Возврат РазобраноНеудачно(СтрокаАнализа);
    Конецесли;
    Конецфункции 
    Функция НеПредикат(Парсер,СтрокаАнализа)
    Результат = ПрименитьПарсер(Парсер.Парсер,СтрокаАнализа);
    Если Неудача(Результат) Тогда
    Возврат РазобраноУспешно(Неопределено,СтрокаАнализа);
    Иначе
    Возврат РазобраноНеудачно(СтрокаАнализа);
    Конецесли;
    Конецфункции 
    Функция ЗарегистрироватьФункцииПарсера(ТипПарсера,ФункцияРазбора)
    СписокФункций[ТипПарсера] = ФункцияРазбора
    Конецфункции
    Функция ПостроитьПарсер(Тип,Аргумент = Неопределено)
    Возврат Новый Структура("Тип,Парсер",Тип,Аргумент);
    Конецфункции
    Функция ПрименитьПарсер(Парсер, СтрокаАнализа)
    ФункцияПарсера = СписокФункций [Парсер.Тип];
    Если ФункцияПарсера = Неопределено Тогда
    Вызватьисключение "Неизвестный тип парсера "+Парсер.Тип;
    Конецесли;
    Возврат Вычислить(ФункцияПарсера + "(Парсер,СтрокаАнализа)");
    Конецфункции
    Процедура Инициализация()
    СписокФункций = Новый Соответствие;
    ЗарегистрироватьФункцииПарсера ("match", "ПарсерОдногоСимвола");
    ЗарегистрироватьФункцииПарсера ("seq", "ПоследовательностьПарсеров");
    ЗарегистрироватьФункцииПарсера ("/", "ОперацияВыбор");
    ЗарегистрироватьФункцииПарсера ("+", "ОдинИлиБолее");
    ЗарегистрироватьФункцииПарсера ("*", "НольИлиБолее");
    ЗарегистрироватьФункцииПарсера ("?", "Необязательно");
    ЗарегистрироватьФункцииПарсера ("!", "НеПредикат");
    ЗарегистрироватьФункцииПарсера ("&", "ИПредикат");
    Конецпроцедуры   
    Процедура Тест_Последовательно() экспорт
    БукваМ = ПостроитьПарсер("match","м");
    БукваА = ПостроитьПарсер("match","а");
    ТестовыйПарсер = ПостроитьПарсер("seq",ВМассив(БукваМ,БукваА,БукваМ,БукваА));
    Результат = ПрименитьПарсер(ТестовыйПарсер,"мама");
    МассивРезультата = ВМассив("м","а","м","а");
    Образец = РазобраноУспешно(МассивРезультата,"");
    Образец = РазобраноУспешно(МассивРезультата,"");
    юТест.ПроверитьРавенство(Результат.Тип, образец.Тип);
    юТест.ПроверитьРавенство(Остаток(Результат), Остаток(образец));
    юТест.ПроверитьРавенство(Значение(Результат)[0], Значение(образец)[0]);
    юТест.ПроверитьРавенство(Значение(Результат)[1], Значение(образец)[1]);
    юТест.ПроверитьРавенство(Значение(Результат)[2], Значение(образец)[2]);
    юТест.ПроверитьРавенство(Значение(Результат)[3], Значение(образец)[3]);
    Конецпроцедуры 
    Процедура Тест_ОперацияВыбор() Экспорт
    БукваМ = ПостроитьПарсер("match","м");
    БукваП = ПостроитьПарсер("match","п");
    БукваА = ПостроитьПарсер("match","а");
    БукваМилиП = ПостроитьПарсер("/",ВМассив(БукваМ,БукваП));
    ТестовыйПарсер = ПостроитьПарсер("seq",ВМассив(БукваМилиП,БукваА,БукваМилиП,БукваА));
    Результат = ПрименитьПарсер(ТестовыйПарсер,"папа");
    МассивРезультата = ВМассив("п","а","п","а");
    Образец = РазобраноУспешно(МассивРезультата,"");
    юТест.ПроверитьРавенство(Результат.Тип, образец.Тип);
    юТест.ПроверитьРавенство(Остаток(Результат), Остаток(образец));
    юТест.ПроверитьРавенство(Значение(Результат)[0], Значение(образец)[0]);
    юТест.ПроверитьРавенство(Значение(Результат)[1], Значение(образец)[1]);
    юТест.ПроверитьРавенство(Значение(Результат)[2], Значение(образец)[2]);
    юТест.ПроверитьРавенство(Значение(Результат)[3], Значение(образец)[3]);
    Конецпроцедуры
    Процедура Тест_ОдинИлиБолее_Один() Экспорт
    БукваМ = ПостроитьПарсер("match","м");
    БукваА = ПостроитьПарсер("match","а");
    БукваМиА = ПостроитьПарсер("seq",ВМассив(БукваМ,БукваА));
    ТестовыйПарсер = ПостроитьПарсер("+",БукваМиА);
    Результат = ПрименитьПарсер(ТестовыйПарсер,"ма");
    МассивРезультата = ВМассив(ВМассив("м","а"));
    Образец = РазобраноУспешно(МассивРезультата,"");
    юТест.ПроверитьРавенство(Результат.Тип, образец.Тип);
    юТест.ПроверитьРавенство(Остаток(Результат), Остаток(образец));
    юТест.ПроверитьРавенство(Значение(Результат)[0][0], Значение(образец)[0][0]);
    юТест.ПроверитьРавенство(Значение(Результат)[0][1], Значение(образец)[0][1]);
    Конецпроцедуры
    Процедура Тест_ОдинИлиБолее_Более() Экспорт
    БукваМ = ПостроитьПарсер("match","м");
    БукваП = ПостроитьПарсер("match","п");
    БукваА = ПостроитьПарсер("match","а");
    БукваМиА = ПостроитьПарсер("seq",ВМассив(БукваМ,БукваА));
    ТестовыйПарсер = ПостроитьПарсер("+",БукваМиА);
    Результат = ПрименитьПарсер(ТестовыйПарсер,"мама");
    МассивРезультата = ВМассив(ВМассив("м","а"),ВМассив("м","а"));
    Образец = РазобраноУспешно(МассивРезультата,"");
    юТест.ПроверитьРавенство(Результат.Тип, образец.Тип);
    юТест.ПроверитьРавенство(Остаток(Результат), Остаток(образец));
    юТест.ПроверитьРавенство(Значение(Результат)[0][0], Значение(образец)[0][0]);
    юТест.ПроверитьРавенство(Значение(Результат)[0][1], Значение(образец)[0][1]);
    юТест.ПроверитьРавенство(Значение(Результат)[1][0], Значение(образец)[1][0]);
    юТест.ПроверитьРавенство(Значение(Результат)[1][1], Значение(образец)[1][1]);
    Конецпроцедуры
    Процедура Тест_ОдинИлиБолее_Ноль() Экспорт
    БукваМ = ПостроитьПарсер("match","м");
    БукваА = ПостроитьПарсер("match","а");
    БукваМиА = ПостроитьПарсер("seq",ВМассив(БукваМ,БукваА));
    ТестовыйПарсер = ПостроитьПарсер("+",БукваМиА);
    Результат = ПрименитьПарсер(ТестовыйПарсер,"папа");
    Образец = РазобраноНеудачно("папа");
    юТест.ПроверитьРавенство(Результат.Тип, образец.Тип);
    юТест.ПроверитьРавенство(Остаток(Результат), Остаток(образец));
    Конецпроцедуры
    Процедура Тест_НольИлиБолее_Ноль() Экспорт
    БукваМ = ПостроитьПарсер("match","м");
    БукваА = ПостроитьПарсер("match","а");
    БукваМиА = ПостроитьПарсер("seq",ВМассив(БукваМ,БукваА));
    ТестовыйПарсер = ПостроитьПарсер("*",БукваМиА);
    Результат = ПрименитьПарсер(ТестовыйПарсер,"папа");
    МассивРезультата = новый Массив;
    Образец = РазобраноУспешно(МассивРезультата,"папа");
    юТест.ПроверитьРавенство(Результат.Тип, образец.Тип);
    юТест.ПроверитьРавенство(Остаток(Результат), Остаток(образец));
    юТест.ПроверитьРавенство(Значение(Результат).Количество(), Значение(образец).Количество());
    Конецпроцедуры
    Процедура Тест_НольИлиБолее_Более() Экспорт
    БукваМ = ПостроитьПарсер("match","м");
    БукваА = ПостроитьПарсер("match","а");
    БукваМиА = ПостроитьПарсер("seq",ВМассив(БукваМ,БукваА));
    ТестовыйПарсер = ПостроитьПарсер("*",БукваМиА);
    Результат = ПрименитьПарсер(ТестовыйПарсер,"мама");
    МассивРезультата = ВМассив(ВМассив("м","а"),ВМассив("м","а"));
    Образец = РазобраноУспешно(МассивРезультата,"");
    юТест.ПроверитьРавенство(Результат.Тип, образец.Тип);
    юТест.ПроверитьРавенство(Остаток(Результат), Остаток(образец));
    юТест.ПроверитьРавенство(Значение(Результат)[0][0], Значение(образец)[0][0]);
    юТест.ПроверитьРавенство(Значение(Результат)[0][1], Значение(образец)[0][1]);
    юТест.ПроверитьРавенство(Значение(Результат)[1][0], Значение(образец)[1][0]);
    юТест.ПроверитьРавенство(Значение(Результат)[1][1], Значение(образец)[1][1]);
    Конецпроцедуры
    Процедура Тест_Необязательно_Есть() Экспорт
    БукваМ = ПостроитьПарсер("match","м");
    БукваА = ПостроитьПарсер("match","а");
    БукваМиА = ПостроитьПарсер("seq",ВМассив(БукваМ,БукваА));
    ТестовыйПарсер = ПостроитьПарсер("?",БукваМиА);
    Результат = ПрименитьПарсер(ТестовыйПарсер,"мама");
    МассивРезультата = ВМассив("м","а");
    Образец = РазобраноУспешно(МассивРезультата,"ма");
    юТест.ПроверитьРавенство(Результат.Тип, образец.Тип);
    юТест.ПроверитьРавенство(Остаток(Результат), Остаток(образец));
    юТест.ПроверитьРавенство(Значение(Результат)[0], Значение(образец)[0]);
    юТест.ПроверитьРавенство(Значение(Результат)[0], Значение(образец)[0]);
    Конецпроцедуры
    Процедура Тест_Необязательно_Нет() Экспорт
    БукваМ = ПостроитьПарсер("match","м");
    БукваА = ПостроитьПарсер("match","а");
    БукваМиА = ПостроитьПарсер("seq",ВМассив(БукваМ,БукваА));
    ТестовыйПарсер = ПостроитьПарсер("?",БукваМиА);
    Результат = ПрименитьПарсер(ТестовыйПарсер,"папа");
    Образец = РазобраноУспешно(Неопределено,"папа");
    юТест.ПроверитьРавенство(Результат.Тип, образец.Тип);
    юТест.ПроверитьРавенство(Остаток(Результат), Остаток(образец));
    юТест.ПроверитьРавенство(Значение(Результат), Значение(образец));
    Конецпроцедуры
    Процедура Тест_ИПредикат() Экспорт
    БукваМ = ПостроитьПарсер("match","м");
    БукваА = ПостроитьПарсер("match","а");
    БукваМиА = ПостроитьПарсер("seq",ВМассив(БукваМ,БукваА));
    ТестовыйПарсер = ПостроитьПарсер("seq",ВМассив(БукваМиА,ПостроитьПарсер("&",БукваМ)));
    Результат = ПрименитьПарсер(ТестовыйПарсер,"мама");
    МассивРезультата = ВМассив(ВМассив("м","а"));
    Образец = РазобраноУспешно(МассивРезультата,"ма");
    юТест.ПроверитьРавенство(Результат.Тип, образец.Тип);
    юТест.ПроверитьРавенство(Остаток(Результат), Остаток(образец));
    юТест.ПроверитьРавенство(Значение(Результат)[0][0], Значение(образец)[0][0]);
    юТест.ПроверитьРавенство(Значение(Результат)[0][1], Значение(образец)[0][1]);
    Конецпроцедуры
    Процедура Тест_НеПредикат() Экспорт
    БукваМ = ПостроитьПарсер("match","м");
    БукваА = ПостроитьПарсер("match","а");
    БукваП = ПостроитьПарсер("match","а");
    БукваМиА = ПостроитьПарсер("seq",ВМассив(БукваМ,БукваА));
    ТестовыйПарсер = ПостроитьПарсер("seq",ВМассив(БукваМиА,ПостроитьПарсер("!",БукваП)));
    Результат = ПрименитьПарсер(ТестовыйПарсер,"мама");
    МассивРезультата = ВМассив(ВМассив("м","а"));
    Образец = РазобраноУспешно(МассивРезультата,"ма");
    юТест.ПроверитьРавенство(Результат.Тип, образец.Тип);
    юТест.ПроверитьРавенство(Остаток(Результат), Остаток(образец));
    юТест.ПроверитьРавенство(Значение(Результат)[0][0], Значение(образец)[0][0]);
    юТест.ПроверитьРавенство(Значение(Результат)[0][1], Значение(образец)[0][1]);
    Конецпроцедуры
    Инициализация();
    }
@para{Запускаем тесты и видим что все в порядке. TDD - вполне приемлемый стиль разработки, как вы видите. Даже в 1С.}
@para{В принципе, этого набора парсеров нам достаточно, что бы реализовать парсер для любой грамматики, которая может быть описана PEG-парсером.
      Но прежде чем приступить к этому, давайте научимся расширять возможности парсеров.}
@section{Расширение возможностей парсеров}
@para{Страшным словом "расширение" на самом деле называется процесс разработки функции разбора и 
      добавления ее в список зарегистрированных функций парсера.}
@subsection{Регистро-независимое сравнение символа}
@para{Первое расширение, которое мы реализуем - сравнение символа без учета регистра. Делается это следующим образом}
@1C{
    Функция ПарсерОдногоСимвола_РегистроНезависимый(Парсер,СтрокаАнализа)
    СимволАнализа = Сред(СтрокаАнализа,1,1);
    Если НРег(СимволАнализа) = НРег(Парсер.Парсер) Тогда
    Возврат РазобраноУспешно(СимволАнализа,Сред(СтрокаАнализа,2));
    Иначе
    Возврат РазобраноНеудачно(СтрокаАнализа);
    Конецесли;
    Конецфункции }
@para{Обычно в регулярных выражениях для обозначения регистро-независимого поиска используется префикс "i". Не будем оригинальны, и добавим определения к нашему парсеру}
@1C{
    ЗарегистрироватьФункцииПарсера ("imatch", "ПарсерОдногоСимвола_РегистроНезависимый");
    }
@para{Напишем тест для проверки - }
@1C{
    Процедура Тест_imatch() экспорт
    БукваМ = ПостроитьПарсер("imatch","м");
    Результат = ПрименитьПарсер(БукваМ,"Мама");
    Образец = РазобраноУспешно("М","ама");
    юТест.ПроверитьРавенство(Результат.Тип, образец.Тип);
    юТест.ПроверитьРавенство(Остаток(Результат), Остаток(образец));
    юТест.ПроверитьРавенство(Значение(Результат), Значение(образец));
    Конецпроцедуры 
    }
@subsection{Сравнение со строкой}
@para{Второе расширение, которое будет нам необходимо - сравнение со строкой. В принципе это и логично - большинство  лексем, которые мы будем извлекать из текста запроса, длиннее одного символа.
      Определим парсер для оператора "match-string"}
@1C{
    Функция ПарсерСтрокиПоОбразцу(Парсер,СтрокаАнализа)
    количестоСимволов = СтрДлина(Парсер.Парсер);
    строка = Сред(СтрокаАнализа,1,количестоСимволов);
    Если строка = Парсер.Парсер Тогда
    Возврат РазобраноУспешно(строка,Сред(СтрокаАнализа,количестоСимволов+1));
    Иначе
    Возврат РазобраноНеудачно(СтрокаАнализа);
    КонецЕсли;
    КонецФункции
    }
@para{Добавим определение в инициализацию}
@1C{
    ЗарегистрироватьФункцииПарсера ("match-string", "ПарсерСтрокиПоОбразцу");
    }
@para{Напишем тест для проверки - }
@1C{
    Процедура Тест_match_string() экспорт
    строкаОбразец = ПостроитьПарсер("match-string","select");
    Результат = ПрименитьПарсер(строкаОбразец,"select 1");
    Образец = РазобраноУспешно("select"," 1");
    юТест.ПроверитьРавенство(Результат.Тип, образец.Тип);
    юТест.ПроверитьРавенство(Остаток(Результат), Остаток(образец));
    юТест.ПроверитьРавенство(Значение(Результат), Значение(образец));
    Конецпроцедуры 
    }
@subsection{Регистро-независимое сравнение со строкой}
@para{Следующее расширение которое опишем – регистро-независимое сравнение со строкой.
      Определим парсер для оператора "imatch-string"}
@1C{
    Функция ПарсерСтрокиПоОбразцу_РегистроНезависимый(Парсер,СтрокаАнализа)
    количестоСимволов = СтрДлина(Парсер.Парсер);
    строка = Сред(СтрокаАнализа,1,количестоСимволов);
    Если НРег(строка) = НРег(Парсер.Парсер) Тогда
    Возврат РазобраноУспешно(строка,Сред(СтрокаАнализа,количестоСимволов+1));
    Иначе
    Возврат РазобраноНеудачно(СтрокаАнализа);
    КонецЕсли;
    КонецФункции
    }
@para{Добавим определение в инициализацию}
@1C{
    ЗарегистрироватьФункцииПарсера ("imatch-string", "ПарсерСтрокиПоОбразцу_РегистроНезависимый");
    }
@para{Напишем тест для проверки - }
@1C{
    Процедура Тест_imatch_string() экспорт
    строкаОбразец = ПостроитьПарсер("imatch-string","select");
    Результат = ПрименитьПарсер(строкаОбразец,"seLECt 1");
    Образец = РазобраноУспешно("seLECt"," 1");
    юТест.ПроверитьРавенство(Результат.Тип, образец.Тип);
    юТест.ПроверитьРавенство(Остаток(Результат), Остаток(образец));
    юТест.ПроверитьРавенство(Значение(Результат), Значение(образец));
    Конецпроцедуры 
    }
@subsection{Интервал}
@para{Небольшой пример - пусть нам необходимо реализовать парсер для следующей грамматики}
@BNF[(list @nonterm{Number}
           @BNF-seq[@nonterm{Digits} @optional[@BNF-group[@nonterm{dot} @nonterm{Digits}]]])
     (list @nonterm{dot} @litchar{.})
     (list @nonterm{Digits} @kleeneplus[@nonterm{Digit}])
     (list @nonterm{Digit} @BNF-alt[@litchar{0} @litchar{1}
                                     @litchar{2} @litchar{3}
                                     @litchar{4} @litchar{5}
                                     @litchar{6} @litchar{7}
                                     @litchar{8} @litchar{9}])]
@para{Во многих лексических сканерах есть альтернативная форма для определения @nonterm{Digit}, а именно - интервал}
@BNF[(list @nonterm{Digit} @optional[@BNF-seq[@litchar{0-9}]])]
@para{Определим такую функцию}
@1C{
    Функция Интервал(Парсер,СтрокаАнализа)
    мин = Парсер.Парсер.Минимум;
    макс = Парсер.Парсер.Максимум;
    символ = Сред(СтрокаАнализа,1,1);
    Если мин<= символ и символ <= макс Тогда
    Возврат РазобраноУспешно(символ,Сред(СтрокаАнализа,2));
    Иначе
    Возврат РазобраноНеудачно(СтрокаАнализа);
    КонецЕсли;
    КонецФункции
    }
@para{Добавим определение в инициализацию}
@1C{
    ЗарегистрироватьФункцииПарсера ("range", "Интервал");
    }
@para{Напишем тест для проверки - }
@1C{
    Процедура Тест_range() экспорт
    цифра = ПостроитьПарсер("range",Новый Структура("Минимум,Максимум","0","9"));
    число = ПостроитьПарсер("+",цифра);
    Результат = ПрименитьПарсер(число,"1234");
    Образец = РазобраноУспешно(ВМассив("1","2","3","4"),"");
    юТест.ПроверитьРавенство(Результат.Тип, образец.Тип);
    юТест.ПроверитьРавенство(Остаток(Результат), Остаток(образец));
    юТест.ПроверитьРавенство(Значение(Результат)[0], Значение(образец)[0]);
    юТест.ПроверитьРавенство(Значение(Результат)[1], Значение(образец)[1]);
    юТест.ПроверитьРавенство(Значение(Результат)[2], Значение(образец)[2]);
    юТест.ПроверитьРавенство(Значение(Результат)[3], Значение(образец)[3]);
    Конецпроцедуры 
    }
@subsection{Сравнение с кодом символа}
@para{Неочевидный парсер, который нам потребуется - сравнение с кодом символа. Дело в том, что символы с ASCII-кодом меньше 48 нельзя ввести с 
      клавиатуры (точнее можно, если использовать Alt+код, но такую возможность не рассматриваем), но вот в тексте, прочитанном из файла, такой символ может встретиться.
      Опишем парсер и подключение к нашей системе}
@1C{
    Функция СравнитьСКодом(Парсер,СтрокаАнализа)
    Символ = Сред(СтрокаАнализа,1,1);
    КодСимвола = КодСимвола(Символ);
    Если Парсер.Парсер = КодСимвола Тогда
    Возврат РазобраноУспешно(символ,Сред(СтрокаАнализа,2));
    Иначе
    Возврат РазобраноНеудачно(СтрокаАнализа);
    КонецЕсли;
    КонецФункции
    }
@para{Добавим определение в инициализацию}
@1C{
    ЗарегистрироватьФункцииПарсера ("char-code", "СравнитьСКодом");
    }
@para{Напишем тест для проверки - }
@1C{
    Процедура Тест_code() экспорт
    //КодСимвола("1") = 49
    цифра = ПостроитьПарсер("char-code",49);
    число = ПостроитьПарсер("+",цифра);
    Результат = ПрименитьПарсер(число,"1234");
    Образец = РазобраноУспешно(ВМассив("1"),"234");
    юТест.ПроверитьРавенство(Результат.Тип, образец.Тип);
    юТест.ПроверитьРавенство(Остаток(Результат), Остаток(образец));
    юТест.ПроверитьРавенство(Значение(Результат)[0], Значение(образец)[0]);
    Конецпроцедуры 
    
    }
@subsection{Преобразование результата}
@para{Следующий неочевидный парсер, который нам потребуется - функция трансформации результата.}
@para{Для чего он нужен? 
      Давайте рассмотрим парсер числа определенный чуть выше и посмотрим что этот парсер @1C{Тест_range()} возвращает - 
      как видим - это массив, но нужен ли он нам? 
      В AST которое мы будем строить, вероятнее потребуется именно число, прочитанное из строки, 
      а не последовательность прочитанных символов. }
@para{Давайте напишем такой парсер }
@1C{
    Функция Преобразователь(Парсер,СтрокаАнализа)
    _Парсер = Парсер.Парсер;
    ФункцияПреобразования = _Парсер.Функция;
    Результат = ПрименитьПарсер(_Парсер.Парсер,СтрокаАнализа);
    Если Успех(Результат) Тогда
    Значение = Вычислить(ФункцияПреобразования+"(Результат)");
    Возврат РазобраноУспешно(Значение,Остаток(Результат));
    КонецЕсли;
    Возврат РазобраноНеудачно(СтрокаАнализа);
    КонецФункции
    }
@para{Добавим определение в инициализацию}
@1C{
    ЗарегистрироватьФункцииПарсера ("fn", "Преобразователь");
    }
@para{Напишем тест для проверки - }
@1C{
    Процедура Тест_fn() экспорт
    цифра = ПостроитьПарсер("range",Новый Структура("Минимум,Максимум","0","9"));
    число = ПостроитьПарсер("+",цифра);
    Преобразователь = ПостроитьПарсер("fn",Новый Структура("Парсер,Функция",число,"РезультатВЧисло"));
    Результат = ПрименитьПарсер(Преобразователь,"1234");
    Образец = РазобраноУспешно(1234,"");
    юТест.ПроверитьРавенство(Результат.Тип, образец.Тип);
    юТест.ПроверитьРавенство(Остаток(Результат), Остаток(образец));
    юТест.ПроверитьРавенство(Значение(Результат), Значение(образец));
    Конецпроцедуры 
    
    
    }
@section{Закрепление материала. Простой парсер markdown-разметки.}
@section{Контроль ошибок и получение позиции анализируемого символа.}
@section{Упрощаем представление парсера.}
@section{Лирическое отступление.}
@section{Кэширование.}
@section{Парсер языка запросов.}
@section{Разработка модуля статического анализа текста запроса.}
@section{Что дальше?}

