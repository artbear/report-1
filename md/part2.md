# Разработка синтаксического анализатора языка запросов на языке 1С

Бомбин Валентин <[wwall@yandex.ru](mailto:wwall@yandex.ru)>

    1 О чем будем говорить?                            
                                                       
    2 Разбор арифметического выражения                 
      2.1 Некрасивая, но нужная реализация             
      2.2 Сделаем симпатично                           
      2.3 Попытаемся расширить граматику               
      2.4 Включим наконец мозг                         
        2.4.1 Для чего эти муки?                       
                                                       
    3 Не пишите код                                    
      3.1 Почему код не надо писать?                   
      3.2 Из чего состоит генератор?                   
      3.3 Что бы понять рекурсию - надо понять рекурсию
      3.4 А что там под капотом?                       
      3.5 Что получилось? Вариант 1                    
      3.6 Отключим мозг - включим фантазию             
      3.7 Лень - высшая форма труда                    
      3.8 А если подумать? Вариант 2                   
      3.9 Пример использования - markdown              
      3.10 Еще немного косметики - v8Unpack            
                                                       
    4 Парсер языка запросов для 1С                     

## 1. О чем будем говорить?

Сегодня мы поговорим о том как имя примитивные парсеры описанные в
предыдущей статье собрать простой генератор синтаксических анализаторов,
построим парсеры для пары простых грамматик и сделаем парсер для языка
запросов. Тема кеширования и получения позиции откладывается до
следующей статьи. Из инструментов чуть позже потребуется утилита
v8Unpack

## 2. Разбор арифметического выражения

Начнем мы с простого - напишем парсер для грамматики разбора
арифметических выражений. Сама грамматика представлена ниже

 >_digits_<   ` ::= `>_[`0-9`]_<+                       
 >_number_<   ` ::= `>_digits_< [{`.` >_digits_<}]      
 >_operation_<` ::= ``+  |  -`                          
 >_exp_<      ` ::= `>_number_< >_operation_< >_number_<

Конечно же бросается в глаза ущербность грамматики, но поводов перживать
нет - по ходу статьи будут добавлены недостающие операции и скобки.
Сейчас для вас главное понять как формальное определение преобразуется в
код, разбирающий строку.

### 2.1. Некрасивая, но нужная реализация

Перевод в код осуществляется буквально - как написано в грамматике - так
и определяем парсеры. Опеределение для

 >_digits_<` ::= `>_[`0-9`]_<+

легко разбивается на 2 парсера - первый разбирает интервал, второй -
одно или более вхождений первого парсера. В коде это выглядит так

digits = ПостроитьПарсер("+",ПостроитьПарсер("range",Новый Структура("Минимум,Максимум","0","9"))); 

На примере теста видно как строить и вызывать парсер :

Функция Парсер\_РазобратьЧисло()
        digits = ПостроитьПарсер("+",ПостроитьПарсер("range",Новый Структура("Минимум,Максимум","0","9")));
        number = ПостроитьПарсер("seq",ВМассив(digits,ПостроитьПарсер("?",ПостроитьПарсер("seq",ВМассив(ПостроитьПарсер("match","."),digits)))));
        Возврат number; Конецфункции
Процедура ТестОпределениеЦелогоЧисла() Экспорт
    результат = ПрименитьПарсер(Парсер\_РазобратьЧисло(),"1234");
        юТест.ПроверитьРавенствоРекурсивно(Значение(результат)[0],ВМассив("1","2","3","4"));
Конецпроцедуры  Процедура ТестОпределениеДробногоЧисла() Экспорт
    результат = ПрименитьПарсер(Парсер\_РазобратьЧисло(),"1234.4321");
        юТест.ПроверитьРавенствоРекурсивно(Значение(результат),ВМассив(ВМассив("1","2","3","4"),ВМассив(".",ВМассив("4","3","2","1"))));
Конецпроцедуры   

Здесь вы видите вызов ПроверитьРавенствоРекурсивно() , в стандартной
поставке xUnitFor1C такого метода нет, пришлось дописать, что бы вы
смотрели на тест, и не отвлекались на операцию сравнения. В дальнейшем
во всей статье будет имельзоваться именно это расширение, скачать его
можно   [здесь](https://github.com/wwall/xUnitFor1C.git)

Оставшиеся нетерминалы - exp,operaiton, number определяются аналогично.
Экономя ваше время, не буду произносить тысячи слов оъяснений, просто
покажу тест

Процедура ТестАрифметика1() Экспорт
        number = Парсер\_РазобратьЧисло();
        operation = ПостроитьПарсер("/",ВМассив(ПостроитьПарсер("match","+"),ПостроитьПарсер("match","-")));
        exp = ПостроитьПарсер("seq",ВМассив(number,operation,number));
        результат = ПрименитьПарсер(exp,"12.34+43.21");
        юТест.ПроверитьРавенствоРекурсивно(Значение(результат),
                ВМассив(                         ВМассив(
                                ВМассив("1","2"),
                                ВМассив(".",ВМассив("3","4"))),
                        "+",                         ВМассив(
                                ВМассив("4","3"),
                                ВМассив(".",ВМассив("2","1")))));
Конецпроцедуры  

Как видим  - строка вполне корректно разбирвается на символы и
группируется по нетерминалам. Осталось простая вещь - преобразовать
результат в число и вернуть его. Определим функцию преобразования
результата в число и напишем тест для проверки.

Функция РезультатВЧисло(значение)
        ЦелаяЧасть = МассивВСтроку(значение(значение)[0]);
        ДробнаяЧасть = "";
        Если Не значение(значение)[1] = Неопределено Тогда
                ДробнаяЧасть = МассивВСтроку(значение(значение)[1][1]);
        Конецесли;         Возврат Число(ЦелаяЧасть+"."+ДробнаяЧасть);
Конецфункции  Функция Парсер\_РазобратьЧисло()
        digits = ПостроитьПарсер("+",ПостроитьПарсер("range",Новый Структура("Минимум,Максимум","0","9")));
        number = ПостроитьПарсер("seq",ВМассив(digits,ПостроитьПарсер("?",ПостроитьПарсер("seq",ВМассив(ПостроитьПарсер("match","."),digits)))));
        Возврат ПостроитьПарсер("fn",Новый Структура("Функция,Парсер","РезультатВЧисло",number));
Конецфункции  

Функция МассивВстроку()  простая и написать ее можете сами, или
посмотреть в файле ariph-2.epf.         А тест заставим сразу проверить
разбор и дробного и целого числа

Процедура ТестПреобразованиеЧисла() Экспорт
        number = Парсер\_РазобратьЧисло();
        результатДробь = ПрименитьПарсер(number,"1234.4321");
        РезультатЦелое = ПрименитьПарсер(number,"1234");
        юТест.ПроверитьРавенство(Значение(результатДробь)+Значение(РезультатЦелое),1234+1234.4321);
Конецпроцедуры 

Теперь когда у нас есть парсер числа и функция преобразования массива в
число, мы можем написать тест для проверки работоспособности парсера
выражения в целом. Выглядеть он будет, например, так :

Процедура ТестРазбор() Экспорт
        number = Парсер\_РазобратьЧисло();
        operation = ПостроитьПарсер("/",ВМассив(ПостроитьПарсер("match","+"),ПостроитьПарсер("match","-")));
        exp = ПостроитьПарсер("fn",Новый Структура("Функция,Парсер","ПрименитьОперацию",ПостроитьПарсер("seq",ВМассив(number,operation,number))));
        результат = ПрименитьПарсер(exp,"12.34+43.21");
        юТест.ПроверитьРавенство(Значение(результат),12.34+43.21);
Конецпроцедуры 

Если что вам в этом коде не понятно - пройдитесь с отладчком по коду в
файле  ariph-2.epf.

На самом деле мы можем на этом остановиться - код реализует заявленный
функционал, но мы его все же препишем. Сделаем код просто посимпотичней
и обоснуем преход который будет выполнен в п. 2.3.

### 2.2. Сделаем симпатично

Первое, о чем возникает мысль (если вы ранее не писали на лиспе), когда
видишь код Парсер\_РазобратьЧисло()  - сократить количество вызовов
функци и скобок. Даже в отсутствие макросов, эта задача не является
сложной, необходимо просто определиться - как будет выгядеть код. Вот
один из вариантов -

Функция Парсер\_РазобратьЧисло()
        digits = \_plus(\_range("0","9"));  _// digits = +[0-9]_
        number = \_seq(digits,\_quest(\_seq(\_match("."),digits))); _//
number = digits ?("." digits)_
        Возврат \_fn("РезультатВЧисло",number); Конецфункции 

Определения для функции \_seq, \_match и т.д. вы можете цвидеть в файле
arith-3.epf. Эта правка - не более чем редактурское упрощение текста,
поэтому тесты из предыдущещего файла вполне подойдут. Приводить их здесь
не буду, но в файле они есть и работают без ошибок

### 2.3. Попытаемся расширить граматику

В начале статьи я обещал вам что наша кастированная грамматика будет
улучшена и позволит разбирать самые сложные выражения. Пришло время это
обещание выполнять. Начнем с грамматики -

 >_digits_<` ::= `>_[`0-9`]_<+                     
 >_X_<     ` ::= `>_digits_< [{`.` >_digits_<}]    
 >_F_<     ` ::= ``(` >_S_< `)  |  `>_X_<          
 >_T_<     ` ::= `>_F_< `*  |  /` >_T_<`  |  `>_F_<
 >_S_<     ` ::= `>_T_< `+  |  -` >_S_<`  |  `>_T_<

Учитывая что все необходимые для работы функции у нас есть, перевод
грамматики не должен составить проблемы. И в первом приближении код
может выглядить так -

Функция Парсер\_РазобратьЧисло()
        digits = \_plus(\_range("0","9")); _ // digits = +[0-9]_
        X = \_seq(digits,\_quest(\_seq(\_match("."),digits))); _//
number = digits ?("." digits)_
        F = \_choose(\_seq(\_match("("),S,\_match(")")),X); 
        T = \_choose(\_seq(F,\_choose(\_match("\*"),\_match("/")),T),F); 
        S = \_choose(\_seq(T,\_choose(\_match("+"),\_match("-")),S),T); 
        Возврат S; Конецфункции 

Работать это код не будет, так как для определения переменной F
требуется переменная S. Конечно, трудолюбивый читатель сможет написать
еще 12 строк кода что бы в текущей модели представления парсера и это
определение работало, но мне почему то кажется что все перейдут к чтению
следующего пункта, и не будут тратить свое время на изобретение
трехколесного велосипеда.

### 2.4. Включим наконец мозг

В принятой ранее модели парсера есть одна, но принципиальная, ошибка. В
ней объявление терминала/нетерминала не отделимо от его описания. В этой
части статьи мы с формулируем требования к новому парсеру.

Очевидно что нам потребуется -

* Иметь возможность много хранить правил

* Иметь возможность объявлять имя правила

* Иметь возможность обращаться к телу правила по имени

* Внести изменения (желательно минимальные) в ранее разработанный код

Исходя из этих требований становится понятно, что нам требуется
коллекция, позволяющая обращаться по ключу. В 1С таких коллекций 2 -
Соответствие и Структура (по большомук счету, вы можете использовать
любую коллекцию, но вот доступ по ключу придется изобретать самому).

Для упрощения работы далее в качестве коллекции будет использована
Структура, но вам ничего не мешает переписать в случае необходимости
свой код под любую другую коллекцию

Напишем ожидаемый код функции и подумаем как бы его обеспечить

Функция ДобавитьОпеределениеВПарсер(Парсер,Имя,ОписаниеПарсера)
        Если Парсер.Свойство(Имя) Тогда
                Вызватьисключение "Уже определено правило:"+Имя;
        Конецесли;         Парсер.Вставить(Имя,ОписаниеПарсера);
Конецфункции  Функция Парсер\_РазобратьЧисло()
        Парсер = Новый Структура;
        ДобавитьОпеределениеВПарсер(Парсер,"digits",\_plus(\_range("0","9")));
        ДобавитьОпеределениеВПарсер(Парсер,"X",\_seq("digits",\_quest(\_seq(\_match("."),"digits"))));
        ДобавитьОпеределениеВПарсер(Парсер,"F",\_choose(\_seq(\_match("("),"S",\_match(")")),"X"));
        ДобавитьОпеределениеВПарсер(Парсер,"T",\_choose(\_seq("F",\_choose(\_match("\*"),\_match("/")),"T"),"F"));
        ДобавитьОпеределениеВПарсер(Парсер,"S",\_choose(\_seq("T",\_choose(\_match("+"),\_match("-")),"F"),"T"));
        Возврат Парсер; Конецфункции 

Так как теперь весь наш парсер собран в одной структуре, то надо
переписать функцию ПрименитьПарсер()  и все функции отвечающие за разбор
примтивов, что бы они умели работать с новым представлением парсера

Ниже приведены 2 функции - ПрименитьПарсер() , и, для понимания работы c
новым представлением парсера, функция ПоследовательностьПарсеров() 

Функция ПоследовательностьПарсеров(ОписаниеПарсера,ПоследовательностьПарсеров,СтрокаАнализа)
        МассивВозврата = Новый Массив;
        СтрокаРаботы = СтрокаАнализа;
        Для Каждого Парсер Из ПоследовательностьПарсеров.Парсер Цикл
                РезультатРаботы = ПрименитьПарсер(ОписаниеПарсера,Парсер,СтрокаРаботы);
                Если Неудача(РезультатРаботы) Тогда
                        Возврат РазобраноНеудачно(СтрокаАнализа);
                Конецесли;
                МассивВозврата.Добавить(ВСтруктуру(Парсер,Значение(РезультатРаботы)));
                СтрокаРаботы = Остаток(РезультатРаботы);
        Конеццикла;
        Возврат РазобраноУспешно(МассивВозврата,СтрокаРаботы,ПоследовательностьПарсеров.Имя);
Конецфункции
Функция ПрименитьПарсер(ОписаниеПарсера,Имя, СтрокаАнализа)
        Парсер = Неопределено;
        Если ТипЗнч(Имя) = Тип("Строка") Тогда
                Если Не ОписаниеПарсера.Свойство(Имя,Парсер) Тогда
                        Вызватьисключение "Не найдено правило "+Имя;
                Конецесли;
                Если ТипЗнч(Парсер) = Тип("Строка") Тогда
                        Возврат ПрименитьПарсер(ОписаниеПарсера,Парсер, СтрокаАнализа);
                Конецесли;         Иначе                 Парсер = Имя;
        Конецесли;         \_Функция = СписокФункций [Парсер.Тип];
        Если \_Функция = Неопределено Тогда
                Вызватьисключение "Неизвестный тип парсера "+Парсер.Тип;
        Конецесли;
        Возврат Вычислить(\_Функция + "(ОписаниеПарсера,Парсер,СтрокаАнализа)");
Конецфункции   

Если что вам в этом коде не понятно - пройдитесь с отладчком по коду в
файле  ariph-4.epf.

> Как вы видите - увиличилось количество параметров, усложнилась немного
> логика выбора парсера и после взгляда на функцию ПрименитьОперацию1() 
> возникает  дежавю - уж не франчайзи ли этот код пишут.Дабы развеять
> опасения - нет, не франчайзи. Сертификтов не получал, писать так же
> красиво, как некоторые франчази "Входящие в TOP-5" не умею, но иногда,
> как вы видите - получается.

#### 2.4.1. Для чего эти муки?

Лирическое отсупление предыдущего абзаца навевает фантазии, и из их
глубины появляется желание не писать ничего кроме грамматики. Вот
конкретно мне хочется написать просто так -

Функция Парсер\_РазобратьЧисло()         Парсер = СоздатьПарсер("
|digits = +[0-9]                 |X = digits ?(""."" disgits)
|F = ""("" S "")"" | X                 |T = F (""\*"" | ""/"") T | F
|S = T (""+"" | ""-"") S | T"; _О том что не выставляет переносы строк
знаю, в финальной версии будет исправлено. Самые нетерпеливые - смотрите
функцию Парсер\_РазобратьЧисло() в файле arith5.epf_
        Возврат Парсер; Конецфункции 

и не думать - как, что, где и в каком порядке объявиться. Раз желание -
мое, то и выполнять мне. Это значит, мой верный читатель, что следующая
часть статьи объяснит тебе ради чего, так долго и муторно ты продирался
через дебри чужого кода.

## 3. Не пишите код

### 3.1. Почему код не надо писать?

В замечательной книге [Эндрю Ханта
"Программист-прагматик"](http://yandex.ru/yandsearch?text=%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%20%D0%BF%D1%80%D0%B0%D0%B3%D0%BC%D0%B0%D1%82%D0%B8%D0%BA)
есть глава посвященная генерации текстов программ. Конкретно сейчас нам
интересны "активные генераторы", то есть такие которые на основании
модели кода генерируют текст.

Самые продвинутые читатели конечно же вспомнили сейчас о таких
программах как yacc, bison, ANTLR. О плюсах которые они дают, ну и
конечно же о минусах. И конечно же жогадались что мы сейчас будем
делать. Что бы не обманывать их ожиданий скажу - да, мы сейчас напишем
генератор лексических анализаторов. Только вот похож он будет больше на
[waxeye](http://waxeye.org/) либо
[PEG.js](https://github.com/pegjs/pegjs)

### 3.2. Из чего состоит генератор?

Генератор текста программы состоит из описания модели, парсера языка
модели и блока формирования/вывода кода.

Таким образом в ближайшее время нам предстоит разработать либо взять
готовый язык описания грамматики, структуру внутреннего представления
прочитаной и разобранной грамматики и сделать процедуру генерации текста
программы по внутреннему представлению.

### 3.3. Что бы понять рекурсию - надо понять рекурсию

Итак, мы начнем с разработки грамматики определяющей грамматику которую
будет уметь обрабатывать генератор парсеров.

Звучит как "масло-маслянное" на первый взгляд. Но это не так. Попробуйте
прочитать первое предложение еще раз вдумчиво и поймете что это не так.
Кстати, если вы вспомнили после второго прочтения слово
"метапрограммирование" - забудьте.

> К этой задаче и этому языку метапрограммирование - не имеет отношения.
> Я, вообще, слабо представляю метапрограммирование на 1С. Может быть в 1С
> версии языка 100500 и появятся макросы, функции как объекты первого
> класса, замыкания и прочие вкусные плюшки, но пока потолок
> метапрограммирования - Выполнить() /Вычислить() .         Меня, как
> разработчика,  это безмерно огорчает, но нет времени/денег/сил на
> разработку своего компилятора 1С.         Так что буду ждать милости от
> разработчиков. Может наигравшись с "Такси" - обратят внимание на язык.

Грамматику для нашего файла определения грамматики возмем
[отсюда](https://github.com/orlandohill/waxeye/blob/master/grammars/waxeye.waxeye)
и модифицируем для наших целей. Изменим немного функции \_seq и
\_choose, и получиться примерно следующее:

Функция СоздатьПарсер(СтрокаОпределенияГрамматики)
        СтруктураПарсера = Новый Структура;
        ДобавитьПравило(СтруктураПарсера,"Grammar",\_seq("Ws","Definition\_star"));
        ДобавитьПравило(СтруктураПарсера,"Definition\_star",\_star("Definition"));
        ДобавитьПравило(СтруктураПарсера,"Definition",\_seq("Identifier","Arrow","Alternation","Ws"));
        ДобавитьПравило(СтруктураПарсера,"Alternation",\_seq("Sequence","AlternationPart\_star"));
        ДобавитьПравило(СтруктураПарсера,"AlternationPart\_star",\_star("AlternationPart"));
        ДобавитьПравило(СтруктураПарсера,"AlternationPart",\_seq("Alt","Sequence"));
        ДобавитьПравило(СтруктураПарсера,"Sequence",\_plus("Unit"));
        ДобавитьПравило(СтруктураПарсера,"Unit",\_seq("Prefix\_star","UnitPart"));
        ДобавитьПравило(СтруктураПарсера,"Prefix\_star",\_star("Prefix"));
        ДобавитьПравило(СтруктураПарсера,"UnitPart",\_choose("Id","OC\_Alternation","Literal","CaseLiteral","CharClass","WildCard"));
        ДобавитьПравило(СтруктураПарсера,"Id",\_seq("Identifier","NotArrow"));
        ДобавитьПравило(СтруктураПарсера,"NotArrow",\_not("Arrow"));
        ДобавитьПравило(СтруктураПарсера,"OC\_Alternation",\_seq("Open","Alternation","Close"));
        ДобавитьПравило(СтруктураПарсера,"Prefix",\_seq("PrefixPart","Ws"));
        ДобавитьПравило(СтруктураПарсера,"PrefixPart",\_match\_or\_list(СтруктураПарсера,"PrefixChar","?\*+&!"));
        ДобавитьПравило(СтруктураПарсера,"Identifier",\_seq("IdFirst","IdRest\_star","Ws"));
        ДобавитьПравило(СтруктураПарсера,"IdFirst",\_choose("range\_az","range\_\_AZ","range\_ая","range\_\_АЯ","underscore"));
        ДобавитьПравило(СтруктураПарсера,"range\_09",\_range("0","9"));
        ДобавитьПравило(СтруктураПарсера,"range\_az",\_range("a","z"));
        ДобавитьПравило(СтруктураПарсера,"range\_\_AZ",\_range("A","Z"));
        ДобавитьПравило(СтруктураПарсера,"range\_ая",\_range("а","я"));
        ДобавитьПравило(СтруктураПарсера,"range\_\_АЯ",\_range("А","Я"));
        ДобавитьПравило(СтруктураПарсера,"underscore",\_match("\_"));
        ДобавитьПравило(СтруктураПарсера,"IdRest\_star",\_star("IdRest"));
        ДобавитьПравило(СтруктураПарсера,"IdRest",\_choose("range\_az","range\_\_AZ","range\_ая","range\_\_АЯ","underscore","range\_09"));
        ДобавитьПравило(СтруктураПарсера,"Literal",\_seq("OpenQuote","Literal\_star","CloseQuote","Ws"));
        ДобавитьПравило(СтруктураПарсера,"OpenQuote",\_match("’"));
        ДобавитьПравило(СтруктураПарсера,"CloseQuote",\_match("’"));
        ДобавитьПравило(СтруктураПарсера,"Literal\_star",\_star("LiteralPart"));
        ДобавитьПравило(СтруктураПарсера,"LiteralPart",\_seq("NotQuote","LChar"));
        ДобавитьПравило(СтруктураПарсера,"NotQuote",\_not("OpenQuote"));
        ДобавитьПравило(СтруктураПарсера,"CaseLiteral",\_seq("OpenDoubleQuote","StringPart","ClosDoubleQuote","Ws"));
        ДобавитьПравило(СтруктураПарсера,"StringPart",\_star(\_seq("NotDoubleQuote","LChar")));
        ДобавитьПравило(СтруктураПарсера,"NotDoubleQuote",\_not("OpenDoubleQuote"));
        ДобавитьПравило(СтруктураПарсера,"OpenDoubleQuote",\_match(""""));
        ДобавитьПравило(СтруктураПарсера,"ClosDoubleQuote",\_match(""""));
        ДобавитьПравило(СтруктураПарсера,"LChar",\_choose("LCharCnst","LCharAny"));
        ДобавитьПравило(СтруктураПарсера,"LCharCnst",\_seq("Slash","SpecialChar"));
        ДобавитьПравило(СтруктураПарсера,"Slash",\_match("\"));
        ДобавитьПравило(СтруктураПарсера,"SpecialChar",\_match\_or\_list(СтруктураПарсера,"SpecialCharList","nrt’""\"));
        ДобавитьПравило(СтруктураПарсера,"LCharAny",\_seq("NotSlash","NotEOL","Any"));
        ДобавитьПравило(СтруктураПарсера,"NotSlash",\_not("Slash"));
        ДобавитьПравило(СтруктураПарсера,"NotEOL",\_not("EndOfLine"));
        ДобавитьПравило(СтруктураПарсера,"Any", any());
        ДобавитьПравило(СтруктураПарсера,"Open\_1",\_match("["));
        ДобавитьПравило(СтруктураПарсера,"Close\_1",\_match("]"));
        ДобавитьПравило(СтруктураПарсера,"CharClass",\_seq("Open\_1", "Ranges" , "Close\_1","Ws"));
        ДобавитьПравило(СтруктураПарсера,"Ranges",\_star("RangeElement"));
        ДобавитьПравило(СтруктураПарсера,"NotClose\_1", \_not("Close\_1"));
        ДобавитьПравило(СтруктураПарсера,"RangeElement",\_seq("NotClose\_1","Range"));
        ДобавитьПравило(СтруктураПарсера,"Range",\_choose("Range0","Char"));
        ДобавитьПравило(СтруктураПарсера,"Minus",\_match("-"));
        ДобавитьПравило(СтруктураПарсера,"Range0",\_seq("Min", "Minus","Max"));
        ДобавитьПравило(СтруктураПарсера,"Max",\_choose("Char0","Char1"));
        ДобавитьПравило(СтруктураПарсера,"Min",\_choose("Char0","Char1"));
        ДобавитьПравило(СтруктураПарсера,"Char",\_choose("Char0","Char1"));
        ДобавитьПравило(СтруктураПарсера,"Char0",\_seq("Slash","SpecialChar\_1"));
        ДобавитьПравило(СтруктураПарсера,"SpecialChar\_1",\_match\_or\_list(СтруктураПарсера,"SpecialCharList\_1","nrt-]\"));
        ДобавитьПравило(СтруктураПарсера,"Char1",\_seq("NotSlash", "NotClose\_1","NotEOL","Any"));
        ДобавитьПравило(СтруктураПарсера,"Arrow",\_seq(ДобавитьПравило(СтруктураПарсера,"ArrowChar",\_match("=")),"Ws"));
        ДобавитьПравило(СтруктураПарсера,"WildCard",\_seq(ДобавитьПравило(СтруктураПарсера,"WildChar",\_match("=")),"Ws"));
        ДобавитьПравило(СтруктураПарсера,"Alt",\_seq(ДобавитьПравило(СтруктураПарсера,"AltChar",\_match("|")),"Ws"));
        ДобавитьПравило(СтруктураПарсера,"Open",\_seq(ДобавитьПравило(СтруктураПарсера,"OpenChar",\_match("(")),"Ws"));
        ДобавитьПравило(СтруктураПарсера,"Close",\_seq(ДобавитьПравило(СтруктураПарсера,"CloseChar",\_match(")")),"Ws"));
        ДобавитьПравило(СтруктураПарсера,"Comma",\_seq(ДобавитьПравило(СтруктураПарсера,"CommaChar",\_match(",")),"Ws"));
        ДобавитьПравило(СтруктураПарсера,"SComment",\_seq("SCommentStart", "SCommentPart", "SCommentEnd"));
        ДобавитьПравило(СтруктураПарсера,"SCommentPart",\_star(ДобавитьПравило(СтруктураПарсера,"CommentChar",\_seq("NotEOL","Any"))));
        ДобавитьПравило(СтруктураПарсера,"SCommentEnd",\_star("EndOfLine"));
        ДобавитьПравило(СтруктураПарсера,"SCommentStart",\_match("//"));
        ДобавитьПравило(СтруктураПарсера,"EndOfLine",\_match\_or\_list(СтруктураПарсера,"EOL",Символы.ПС+Символы.ВК));
        ДобавитьПравило(СтруктураПарсера,"WsPart",\_choose(ДобавитьПравило(СтруктураПарсера,"SpaceTab",\_match\_or\_list(СтруктураПарсера,"SpaceTabValue","
"+Символы.Таб)),"EndOfLine","SComment"));
        ДобавитьПравило(СтруктураПарсера,"Ws",\_star("WsPart"));
        Возврат ПрименитьПарсер(СтруктураПарсера,"Grammar",СтрокаОпределенияГрамматики);
Конецфункции  

Что бы не загромождать текст кодом, тест здесь не публикую, но в файле
arith5.epf он есть. Как видите - назначение этой функции по переданной
грамматике разобрать строку и получить внутренее представление для
дальнейшей обработки. Фактически самый сложный этап мы сделали. Осталось
всего ничего - написать интерпретатор для обхода получившейся структуры.
Чем мы и займемся.

### 3.4. А что там под капотом?


### 3.5. Что получилось? Вариант 1


### 3.6. Отключим мозг - включим фантазию


### 3.7. Лень - высшая форма труда


### 3.8. А если подумать? Вариант 2


### 3.9. Пример использования - markdown


### 3.10. Еще немного косметики - v8Unpack


## 4. Парсер языка запросов для 1С

