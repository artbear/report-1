#lang scribble/doc
@(require scribble/core) 
@(require scribble/manual)
@(require scribble/bnf)
@(require "lang/lexer.scm")
@(define (todo . s)
   (let [(text (list (string-append "TODO " (car s))))]
     (red-text text))) 
@(define (green-text . s)
   @italic[@elem[s #:style (style #f (list (color-property "green")))]]) 
@(define (black-text . s)
   @elem[s #:style (style #f (list (color-property "black")))]) 
@(define (red-text . s)
   @elem[s #:style (style #f (list (color-property "red")))]) 
@(define (blue-text . s)
   @elem[s #:style (style #f (list (color-property "blue")))]) 
@(define (1C-colorize x y)
   (cond 
     [(keyword?  x) (red-text (string-titlecase y))]
     [(eq? 'tknID x) (blue-text y)]
     [(eq? 'tknSTRING x) (black-text (string-append "\"" y "\""))]
     [(eq? 'tknNUMBER x) (black-text y)]
     [(eq? 'tknWS x) (hspace (string-length y))]
     [(eq? 'tknNL x) (linebreak)]
     [(eq? 'tknSQEUENCE x) (green-text y)]
     [else  (red-text y)]))

@(define (1C . s)
   (let [(token-list (lex->list s))]
     (map (lambda (x) (1C-colorize (car x) (cadr x))) token-list))) 
@title[#:version "0.1"
                 #:date "2014-11-24"]{Разработка синтаксического анализатора языка запросов на языке 1С}
@(author+email "Бомбин Валентин" "wwall@yandex.ru" #:obfuscate? #f)
@;----@local-table-of-contents[]
@section{О чем будем говорить?}
Сегодня мы поговорим о том как имя примитивные парсеры описанные в предыдущей статье собрать простой генератор синтаксических анализаторов, построим парсеры для пары простых грамматик и сделаем парсер для языка запросов. Тема кеширования и получения позиции откладывается до следующей статьи.
Из инструментов чуть позже потребуется утилита v8Unpack
@section{Разбор арифметического выражения}
Начнем мы с простого - напишем парсер для грамматики разбора арифметических выражений. Сама грамматика представлена ниже
@BNF[(list @nonterm{digits} @kleeneplus[@nonterm{@optional[@BNF-seq[@litchar{0-9}]]}])
     (list @nonterm{number}
           @BNF-seq[@nonterm{digits} @optional[@BNF-group[@litchar{.} @nonterm{digits}]]])
     (list @nonterm{operation} @BNF-alt[@litchar{+} @litchar{-}])
     (list @nonterm{exp}
           @BNF-seq[@nonterm{number} @nonterm{operation} @nonterm{number}])]
@para{Конечно же бросается в глаза ущербность грамматики, но поводов перживать нет - по ходу статьи будут добавлены недостающие операции и скобки. Сейчас для вас главное понять как формальное определение преобразуется в код, разбирающий строку.}
@subsection{Некрасивая, но нужная реализация}

@para{Перевод в код осуществляется буквально - как написано в грамматике - так и определяем парсеры. Опеределение для}
@BNF[(list @nonterm{digits} @kleeneplus[@nonterm{@optional[@BNF-seq[@litchar{0-9}]]}])] 
@para{легко разбивается на 2 парсера - первый разбирает интервал, второй - одно или более вхождений первого парсера. В коде это выглядит так}
@1C{digits = ПостроитьПарсер("+",ПостроитьПарсер("range",Новый Структура("Минимум,Максимум","0","9")));}
@para{На примере теста видно как строить и вызывать парсер :}
@1C{
Процедура ТестОпределениеЦелогоЧисла() Экспорт
	digits = ПостроитьПарсер("+",ПостроитьПарсер("range",Новый Структура("Минимум,Максимум","0","9")));
    результат = ПрименитьПарсер(digits,"1234");
	юТест.ПроверитьРавенствоРекурсивно(Значение(результат),ВМассив("1","2","3","4"));
КонецПроцедуры}
@para{Здесь вы видите вызов @1C{ПроверитьРавенствоРекурсивно()}, в стандартной поставке xUnitFor1C такого метода нет, пришлось дописать, что бы вы смотрели на тест, и не отвлекались на операцию сравнения. В дальнейшем во всей статье будет имельзоваться именно это расширение, скачать его можно   @link["https://github.com/wwall/xUnitFor1C.git"]{здесь}}
@para{Оставшиеся нетерминалы - exp,operaiton, number определяются аналогично. Экономя ваше время, не буду произносить тысячи слов оъяснений, просто покажу тест }
@1C{
Процедура ТестАрифметика1() Экспорт
	digits = ПостроитьПарсер("+",ПостроитьПарсер("range",Новый Структура("Минимум,Максимум","0","9")));
	number = ПостроитьПарсер("seq",ВМассив(digits,ПостроитьПарсер("?",ПостроитьПарсер("seq",ВМассив(ПостроитьПарсер("match","."),digits)))));
	operation = ПостроитьПарсер("/",ВМассив(ПостроитьПарсер("match","+"),ПостроитьПарсер("match","-")));
	exp = ПостроитьПарсер("seq",ВМассив(number,operation,number));
	
	результат = ПрименитьПарсер(exp,"12.34+43.21");
	
	юТест.ПроверитьРавенствоРекурсивно(Значение(результат),ВМассив(ВМассив(ВМассив("1","2"),ВМассив(".",ВМассив("3","4"))),"+",ВМассив(ВМассив("4","3"),ВМассив(".",ВМассив("2","1")))));
КонецПроцедуры
}
@para{Как видим  -строка вполне корректно разбирвается на символы и группируется по нетерминалам. Осталось простая вещь - преобразовать результат в число и вернуть его. Определим функцию преобразования результата в число и напишем тест для проверки.}
@1C{
Функция РезультатВЧисло(значение)
	ЦелаяЧасть = МассивВСтроку(значение(значение)[0]);
	ДробнаяЧасть = "";
	Если не значение(значение)[1] = Неопределено Тогда
		ДробнаяЧасть = МассивВСтроку(значение(значение)[1][1]);
	КонецЕсли;
	
	
	Возврат Число(ЦелаяЧасть+"."+ДробнаяЧасть);
КонецФункции}
@para{Функция @1C{МассивВстроку()} простая и написать ее можете сами, или посмотреть в файле арифметика-2.epf.
              А тест заставим сразу проверить разбор и дробного и целого числа}
@1C{
Процедура ТестПреобразованиеЧисла() Экспорт
	digits = ПостроитьПарсер("+",ПостроитьПарсер("range",Новый Структура("Минимум,Максимум","0","9")));
	number = ПостроитьПарсер("fn",Новый Структура("Функция,Парсер","РезультатВЧисло",ПостроитьПарсер("seq",ВМассив(digits,ПостроитьПарсер("?",ПостроитьПарсер("seq",ВМассив(ПостроитьПарсер("match","."),digits)))))));
	результатДробь = ПрименитьПарсер(number,"1234.4321");
	РезультатЦелое = ПрименитьПарсер(number,"1234");
	юТест.ПроверитьРавенство(Значение(результатДробь)+Значение(РезультатЦелое),1234+1234.4321);
КонецПроцедуры
}

@para{Теперь когда у нас есть парсер числа и функция преобразования массива в число, мы можем написать тест для проверки работоспособности парсера выражения в целом.
      Выглядеть он будет, например, так :}

@1C{
Процедура ТестРазбор() Экспорт
	digits = ПостроитьПарсер("+",ПостроитьПарсер("range",Новый Структура("Минимум,Максимум","0","9")));
	number = ПостроитьПарсер("fn",Новый Структура("Функция,Парсер","РезультатВЧисло",ПостроитьПарсер("seq",ВМассив(digits,ПостроитьПарсер("?",ПостроитьПарсер("seq",ВМассив(ПостроитьПарсер("match","."),digits)))))));
	operation = ПостроитьПарсер("/",ВМассив(ПостроитьПарсер("match","+"),ПостроитьПарсер("match","-")));
	exp = ПостроитьПарсер("fn",Новый Структура("Функция,Парсер","ПрименитьОперацию",ПостроитьПарсер("seq",ВМассив(number,operation,number))));
	
	результат = ПрименитьПарсер(exp,"12.34+43.21");
	юТест.ПроверитьРавенство(Значение(результат),12.34+43.21);
КонецПроцедуры
}

@para{Если что вам в этом коде не понятно - пройдитесь с отладчком по коду в файле  арифметика-2.epf.}
@para{На самом деле мы можем на этом остановиться - код реализует заявленный функционал, но мы его все же препишем. Сделаем код просто посимпотичней и обоснуем преход который будет выполнен в п. 2.3. }
      
      
      @subsection{Сделаем симпатично}
      @para{Напишем простой тест для проверки тестовой грамматики}
      @subsection{Включим наконец мозг}
      @subsubsection{Для чего?}
      @subsubsection{Как?}
      @subsubsection{Что получилось?}      
      @subsubsection{Для чего эти муки?}
      @section{Не пишите код}
      
      @subsection{Почему код не надо писать?}
      @subsection{Из чего состоит генератор?}
      @subsection{Что бы понять рекурсию - надо понять рекурсию}
      @subsection{Отключим мозг - включим фантазию}
      @subsection{Лень - высшая форма труда}
      @subsection{Что получилось? Вариант 1}
      @subsection{А если подумать? Вариант 2}
      @subsection{Пример использования - markdown}
      @subsection{Еще немного косметики - v8Unpack}
      
      @section{Парсер языка запросов для 1С}
      
      
      @section{А что дальше?}
      @section{Пару слов в заключении}
      


