#lang scribble/doc
@(require scribble/core) 
@(require scribble/manual)
@(require scribble/bnf)
@(require "lang/lexer.scm")
@(define (todo . s)
   (let [(text (list (string-append "TODO " (car s))))]
     (red-text text))) 
@(define (green-text . s)
   @italic[@elem[s #:style (style #f (list (color-property "green")))]]) 
@(define (black-text . s)
   @elem[s #:style (style #f (list (color-property "black")))]) 
@(define (red-text . s)
   @elem[s #:style (style #f (list (color-property "red")))]) 
@(define (blue-text . s)
   @elem[s #:style (style #f (list (color-property "blue")))]) 
@(define (1C-colorize x y)
   (cond 
     [(keyword?  x) (red-text (string-titlecase y))]
     [(eq? 'tknID x) (blue-text y)]
     [(eq? 'tknSTRING x) (black-text (string-append "\"" y "\""))]
     [(eq? 'tknNUMBER x) (black-text y)]
     [(eq? 'tknWS x) (hspace (string-length y))]
     [(eq? 'tknNL x) (linebreak)]
     [(eq? 'tknSQEUENCE x) (green-text y)]
     [else  (red-text y)]))

@(define (1C . s)
   (let [(token-list (lex->list s))]
     (map (lambda (x) (1C-colorize (car x) (cadr x))) token-list))) 
@title[#:version "0.1"
                 #:date "2014-11-24"]{Разработка синтаксического анализатора языка запросов на языке 1С}
@(author+email "Бомбин Валентин" "wwall@yandex.ru" #:obfuscate? #f)
@;----@local-table-of-contents[]
@section{О чем будем говорить?}
Сегодня мы поговорим о том как имя примитивные парсеры описанные в предыдущей статье собрать простой генератор синтаксических анализаторов, построим парсеры для пары простых грамматик и сделаем парсер для языка запросов. Тема кеширования и получения позиции откладывается до следующей статьи.
Из инструментов чуть позже потребуется утилита v8Unpack
@section{Разбор арифметического выражения}
Начнем мы с простого - напишем парсер для грамматики разбора арифметических выражений. Сама грамматика представлена ниже
@BNF[(list @nonterm{digits} @kleeneplus[@nonterm{@optional[@BNF-seq[@litchar{0-9}]]}])
     (list @nonterm{number}
           @BNF-seq[@nonterm{digits} @optional[@BNF-group[@litchar{.} @nonterm{digits}]]])
     (list @nonterm{operation} @BNF-alt[@litchar{+} @litchar{-}])
     (list @nonterm{exp}
           @BNF-seq[@nonterm{number} @nonterm{operation} @nonterm{number}])]
@para{Конечно же бросается в глаза ущербность грамматики, но поводов перживать нет - по ходу статьи будут добавлены недостающие операции и скобки. Сейчас для вас главное понять как формальное определение преобразуется в код, разбирающий строку.}
@subsection{Некрасивая, но нужная реализация}

@para{Перевод в код осуществляется буквально - как написано в грамматике - так и определяем парсеры. Опеределение для}
@BNF[(list @nonterm{digits} @kleeneplus[@nonterm{@optional[@BNF-seq[@litchar{0-9}]]}])] 
@para{легко разбивается на 2 парсера - первый разбирает интервал, второй - одно или более вхождений первого парсера. В коде это выглядит так}
@1C{digits = ПостроитьПарсер("+",ПостроитьПарсер("range",Новый Структура("Минимум,Максимум","0","9")));}
@para{На примере теста видно как строить и вызывать парсер :}
@1C{

Функция Парсер_РазобратьЧисло()
	digits = ПостроитьПарсер("+",ПостроитьПарсер("range",Новый Структура("Минимум,Максимум","0","9")));
	number = ПостроитьПарсер("seq",ВМассив(digits,ПостроитьПарсер("?",ПостроитьПарсер("seq",ВМассив(ПостроитьПарсер("match","."),digits)))));
	Возврат number;
КонецФункции


Процедура ТестОпределениеЦелогоЧисла() Экспорт
    результат = ПрименитьПарсер(Парсер_РазобратьЧисло(),"1234");
	юТест.ПроверитьРавенствоРекурсивно(Значение(результат)[0],ВМассив("1","2","3","4"));
КонецПроцедуры

Процедура ТестОпределениеДробногоЧисла() Экспорт
    результат = ПрименитьПарсер(Парсер_РазобратьЧисло(),"1234.4321");
	юТест.ПроверитьРавенствоРекурсивно(Значение(результат),ВМассив(ВМассив("1","2","3","4"),ВМассив(".",ВМассив("4","3","2","1"))));
КонецПроцедуры


}
@para{Здесь вы видите вызов @1C{ПроверитьРавенствоРекурсивно()}, в стандартной поставке xUnitFor1C такого метода нет, пришлось дописать, что бы вы смотрели на тест, и не отвлекались на операцию сравнения. В дальнейшем во всей статье будет имельзоваться именно это расширение, скачать его можно   @link["https://github.com/wwall/xUnitFor1C.git"]{здесь}}
@para{Оставшиеся нетерминалы - exp,operaiton, number определяются аналогично. Экономя ваше время, не буду произносить тысячи слов оъяснений, просто покажу тест }
@1C{
Процедура ТестАрифметика1() Экспорт
	number = Парсер_РазобратьЧисло();
	operation = ПостроитьПарсер("/",ВМассив(ПостроитьПарсер("match","+"),ПостроитьПарсер("match","-")));
	exp = ПостроитьПарсер("seq",ВМассив(number,operation,number));
	
	результат = ПрименитьПарсер(exp,"12.34+43.21");
	
	юТест.ПроверитьРавенствоРекурсивно(Значение(результат),
		ВМассив(
			ВМассив(
				ВМассив("1","2"),
				ВМассив(".",ВМассив("3","4"))),
			"+",
			ВМассив(
				ВМассив("4","3"),
				ВМассив(".",ВМассив("2","1")))));
КонецПроцедуры

}
@para{Как видим  - строка вполне корректно разбирвается на символы и группируется по нетерминалам. Осталось простая вещь - преобразовать результат в число и вернуть его. Определим функцию преобразования результата в число и напишем тест для проверки.}
@1C{
Функция РезультатВЧисло(значение)
	ЦелаяЧасть = МассивВСтроку(значение(значение)[0]);
	ДробнаяЧасть = "";
	Если не значение(значение)[1] = Неопределено Тогда
		ДробнаяЧасть = МассивВСтроку(значение(значение)[1][1]);
	КонецЕсли;
	
	
	Возврат Число(ЦелаяЧасть+"."+ДробнаяЧасть);
КонецФункции

Функция Парсер_РазобратьЧисло()
	digits = ПостроитьПарсер("+",ПостроитьПарсер("range",Новый Структура("Минимум,Максимум","0","9")));
	number = ПостроитьПарсер("seq",ВМассив(digits,ПостроитьПарсер("?",ПостроитьПарсер("seq",ВМассив(ПостроитьПарсер("match","."),digits)))));
	Возврат ПостроитьПарсер("fn",Новый Структура("Функция,Парсер","РезультатВЧисло",number));
КонецФункции

}
@para{Функция @1C{МассивВстроку()} простая и написать ее можете сами, или посмотреть в файле ariph-2.epf.
              А тест заставим сразу проверить разбор и дробного и целого числа}
@1C{
Процедура ТестПреобразованиеЧисла() Экспорт
	number = Парсер_РазобратьЧисло();
	результатДробь = ПрименитьПарсер(number,"1234.4321");
	РезультатЦелое = ПрименитьПарсер(number,"1234");
	юТест.ПроверитьРавенство(Значение(результатДробь)+Значение(РезультатЦелое),1234+1234.4321);
КонецПроцедуры
}

@para{Теперь когда у нас есть парсер числа и функция преобразования массива в число, мы можем написать тест для проверки работоспособности парсера выражения в целом.
      Выглядеть он будет, например, так :}

@1C{
Процедура ТестРазбор() Экспорт
	number = Парсер_РазобратьЧисло();
	operation = ПостроитьПарсер("/",ВМассив(ПостроитьПарсер("match","+"),ПостроитьПарсер("match","-")));
	exp = ПостроитьПарсер("fn",Новый Структура("Функция,Парсер","ПрименитьОперацию",ПостроитьПарсер("seq",ВМассив(number,operation,number))));
	результат = ПрименитьПарсер(exp,"12.34+43.21");
	юТест.ПроверитьРавенство(Значение(результат),12.34+43.21);
КонецПроцедуры
}

@para{Если что вам в этом коде не понятно - пройдитесь с отладчком по коду в файле  ariph-2.epf.}
@para{На самом деле мы можем на этом остановиться - код реализует заявленный функционал, но мы его все же препишем. Сделаем код просто посимпотичней и обоснуем преход который будет выполнен в п. 2.3. }
      @subsection{Сделаем симпатично}
@para{Первое, о чем возникает мысль (если вы ранее не писали на лиспе), когда видишь код @1C{Парсер_РазобратьЧисло()} - сократить количество вызовов функци и скобок. Даже в отсутствие макросов, эта задача не является сложной, необходимо просто определиться - как будет выгядеть код. Вот один из вариантов - } 
@1C{
Функция Парсер_РазобратьЧисло()
	digits = _plus(_range("0","9"));  ~// digits = +[0-9]~
	number = _seq(digits,_quest(_seq(_match("."),digits))); ~// number = digits ?("." digits)~
	Возврат _fn("РезультатВЧисло",number);
КонецФункции
} 
@para{Определения для функции _seq, _match и т.д. вы можете цвидеть в файле arith-3.epf. Эта правка - не более чем редактурское упрощение текста, поэтому тесты из предыдущещего файла вполне подойдут. Приводить их здесь не буду, но в файле они есть и работают без ошибок } 

@subsection{Попытаемся расширить граматику}
@para{В начале статьи я обещал вам что наша кастированная грамматика будет улучшена и позволит разбирать самые сложные выражения. Пришло время это обещание выполнять. Начнем с грамматики - }

@BNF[(list @nonterm{digits} @kleeneplus[@nonterm{@optional[@BNF-seq[@litchar{0-9}]]}])
     (list @nonterm{X} @BNF-seq[@nonterm{digits} @optional[@BNF-group[@litchar{.} @nonterm{digits}]]])
     (list @nonterm{F} @BNF-alt[
                                @BNF-seq[@litchar{(} @nonterm{S} @litchar{)}]
                                 @nonterm{X}])
     (list @nonterm{T} @BNF-alt[
                                @BNF-seq[@nonterm{F} @BNF-alt[@litchar{*} @litchar{/}] @nonterm{T}]
                                 @nonterm{F}]) 
     (list @nonterm{S} @BNF-alt[
                                @BNF-seq[@nonterm{T} @BNF-alt[@litchar{+} @litchar{-}] @nonterm{S}]
                                 @nonterm{T}])]
@para{Учитывая что все необходимые для работы функции у нас есть, перевод грамматики не должен составить проблемы. И в первом приближении код может выглядить так - }
@1C{

Функция Парсер_РазобратьЧисло()
	digits = _plus(_range("0","9")); ~ // digits = +[0-9]~
	X = _seq(digits,_quest(_seq(_match("."),digits))); ~// number = digits ?("." digits)~
	F = _choose(_seq(_match("("),S,_match(")")),X); // ~"(" S ")" | X~
	T = _choose(_seq(F,_choose(_match("*"),_match("/")),T),F); // ~T ("*" | "/") F | F~
	S = _choose(_seq(T,_choose(_match("+"),_match("-")),S),T); // ~S ("+" | "-") T | T~
	Возврат S;
КонецФункции}

@para{Работать это код не будет, так как для определения переменной F требуется переменная S. Конечно, трудолюбивый читатель сможет написать еще 12 строк кода что бы в текущей модели представления парсера и это определение работало, но мне почему то кажется что все перейдут к чтению следующего пункта, и не будут тратить свое время на изобретение трехколесного велосипеда.}
      @subsection{Включим наконец мозг}
@para{В принятой ранее модели парсера есть одна, но принципиальная, ошибка. В ней объявление терминала/нетерминала не отделимо от его описания. В этой части статьи мы с формулируем требования к новому парсеру.}
@para{Очевидно что нам потребуется - }
      @itemize[
               @item{
                     @para{Иметь возможность много хранить правил}}
               @item{
                     @para{Иметь возможность объявлять имя правила}}
                @item{
                      @para{Иметь возможность обращаться к телу правила по имени}}
                @item{
                      @para{Внести изменения (желательно минимальные) в ранее разработанный код}}]
@para{Исходя из этих требований становится понятно, что нам требуется коллекция, позволяющая обращаться по ключу. В 1С таких коллекций 2 - Соответствие и Структура (по большомук счету, вы можете использовать любую коллекцию, но вот доступ по ключу придется изобретать самому).}
@para{Для упрощения работы далее в качестве коллекции будет использована Структура, но вам ничего не мешает переписать в случае необходимости свой код под любую другую коллекцию}

@para{Напишем ожидаемый код функции и подумаем как бы его обеспечить}


@1C{
Функция ДобавитьОпеределениеВПарсер(Парсер,Имя,ОписаниеПарсера)
	Если Парсер.Свойство(Имя) Тогда
		ВызватьИсключение "Уже определено правило:"+Имя;
	КонецЕсли;
	Парсер.Вставить(Имя,ОписаниеПарсера);
КонецФункции

Функция Парсер_РазобратьЧисло()
	Парсер = новый Структура;
	ДобавитьОпеределениеВПарсер(Парсер,"digits",_plus(_range("0","9")));
	ДобавитьОпеределениеВПарсер(Парсер,"X",_seq("digits",_quest(_seq(_match("."),"digits"))));
	ДобавитьОпеределениеВПарсер(Парсер,"F",_choose(_seq(_match("("),"S",_match(")")),"X"));
	ДобавитьОпеределениеВПарсер(Парсер,"T",_choose(_seq("F",_choose(_match("*"),_match("/")),"T"),"F"));
	ДобавитьОпеределениеВПарсер(Парсер,"S",_choose(_seq("T",_choose(_match("+"),_match("-")),"F"),"T")); 
	Возврат Парсер;
КонецФункции
}

@para{Так как теперь весь наш парсер собран в одной структуре, то надо переписать функцию @1C{ПрименитьПарсер()} и все функции отвечающие за разбор примтивов, что бы они умели работать с новым представлением парсера}
@para{Ниже приведены 2 функции - @1C{ПрименитьПарсер()}, и, для понимания работы c новым представлением парсера, функция @1C{ПоследовательностьПарсеров()}}
@1C{

Функция ПоследовательностьПарсеров(ОписаниеПарсера,ПоследовательностьПарсеров,СтрокаАнализа)
	МассивВозврата = Новый Массив;
	СтрокаРаботы = СтрокаАнализа;
	Для Каждого Парсер Из ПоследовательностьПарсеров.Парсер Цикл
		РезультатРаботы = ПрименитьПарсер(ОписаниеПарсера,Парсер,СтрокаРаботы);
		Если Неудача(РезультатРаботы) Тогда
			Возврат РазобраноНеудачно(СтрокаАнализа);
		Конецесли;
		МассивВозврата.Добавить(ВСтруктуру(Парсер,Значение(РезультатРаботы)));
		СтрокаРаботы = Остаток(РезультатРаботы);
	Конеццикла;
	Возврат РазобраноУспешно(МассивВозврата,СтрокаРаботы,ПоследовательностьПарсеров.Имя);
Конецфункции 



Функция ПрименитьПарсер(ОписаниеПарсера,Имя, СтрокаАнализа)
	Парсер = Неопределено;
	Если ТипЗнч(Имя) = Тип("Строка") Тогда
		Если не ОписаниеПарсера.Свойство(Имя,Парсер) Тогда
			ВызватьИсключение "Не найдено правило "+Имя;
		КонецЕсли;
		Если ТипЗнч(Парсер) = Тип("Строка") Тогда
			Возврат ПрименитьПарсер(ОписаниеПарсера,Парсер, СтрокаАнализа);
		КонецЕсли;
	Иначе
		Парсер = Имя;
	КонецЕсли;
	_Функция = СписокФункций [Парсер.Тип];
	Если _Функция = Неопределено Тогда
		Вызватьисключение "Неизвестный тип парсера "+Парсер.Тип;
	Конецесли;
	
	Возврат Вычислить(_Функция + "(ОписаниеПарсера,Парсер,СтрокаАнализа)");
Конецфункции


}

@para{Если что вам в этом коде не понятно - пройдитесь с отладчком по коду в файле  ariph-4.epf.}
@para{Как вы видите - увиличилось количество параметров, усложнилась немного логика выбора парсера и после взгляда на функцию @1C{ПрименитьОперацию1()} возникает  дежавю - 
уж не франчайзи ли этот код пишут.Дабы развеять опасения - нет, не франчайзи. Сертификтов не получал, писать так же красиво, как некоторые франчази "Входящие в TOP-5" не умею.}
@subsubsection{Для чего эти муки?}
@para{Лирическое отсупление предыдущего абзаца навевает фантазии, и из их глубины появляется желание не писать ничего кроме грамматики. Вот конкретно мне хочется написать просто так - }
@1C{

Функция Парсер_РазобратьЧисло()
	Парсер = СоздатьПарсер("
		|digits = +[0-9]
		|X = digits ?(""."" disgits)
		|F = ""("" S "")"" | X
		|T = F (""*"" | ""/"") T | F
		|S = T (""+"" | ""-"") S | T"; ~О том что не выставляет переносы строк знаю, в финальной версии будет исправлено. Самые нетерпеливые - смотрите функцию Парсер_РазобратьЧисло() в файле arith5.epf~
	Возврат Парсер;
КонецФункции
}

@para{и не думать - как, что, где и в каком порядке объявиться. 
Раз желание - мое, то и выполнять мне. Это значит, мой верный читатель, что следующая часть статьи объяснит тебе ради чего, так долго и муторно ты продирался через дебри чужого кода.}
      @section{Не пишите код}
      
      @subsection{Почему код не надо писать?}
      @subsection{Из чего состоит генератор?}
      @subsection{Что бы понять рекурсию - надо понять рекурсию}
      @subsection{Отключим мозг - включим фантазию}
      @subsection{Лень - высшая форма труда}
      @subsection{Что получилось? Вариант 1}
      @subsection{А если подумать? Вариант 2}
      @subsection{Пример использования - markdown}
      @subsection{Еще немного косметики - v8Unpack}
      
      @section{Парсер языка запросов для 1С}
      
      
      @section{А что дальше?}
      @section{Пару слов в заключении}
      


